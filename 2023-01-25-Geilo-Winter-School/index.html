<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title><code>Turing.jl</code></title>
<meta name="author" content="Tor Erlend Fjelde"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/reveal.css"/>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/theme/white.css" id="theme"/>

<link rel="stylesheet" href="custom.css"/>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><div><div style="margin: -200px auto; opacity: 0.2;"><p><object data="https://turing.ml/dev/assets/images/turing-logo-wide.svg"></object></p></div><h1>Bayesian inference and other things</h1><h2>with the TuringLang ecosystem</h2><p><a href="https://github.com/TuringLang">https://github.com/TuringLang</a></p><p><a href="https://github.com/TuringLang/Turing-Workshop/tree/main/2023-Geilo-Winter-School/Part-2-Turing-and-other-things">The workshop is found here</a></p></div>
</section>

<section>
<section id="slide-2023-01-29-16-57-28-Before-we-begin">
<h2 id="2023-01-29-16-57-28-Before-we-begin">Before we begin</h2>
<p>
Make sure you're in the correct directory
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>pwd()
</code></pre>
</div>

<pre class="example">
"/home/tor/Projects/public/Turing-Workshop/2023-Geilo-Winter-School/Part-2-Turing-and-other-things"
</pre>


<p>
Then run something like (depending on which OS you are on)
</p>

<div class="org-src-container">

<pre  class="src src-sh"   ><code trim>julia --project
</code></pre>
</div>

<p>
or if you're already in a REPL, do
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>]activate .
</code></pre>
</div>

<pre class="example">
Activating project at `~/Projects/public/Turing-Workshop/2023-Geilo-Winter-School/Part-2-Turing-and-other-things`
</pre>


<p>
to activate the project
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Before-we-begin-split">

<p>
And just to check that you're in the correct one
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>]status
</code></pre>
</div>

<pre class="example">
Project GeiloWinterSchool2023Part2 v0.1.0
Status `~/Projects/public/Turing-Workshop/2023-Geilo-Winter-School/Part-2-Turing-and-other-things/Project.toml`
  [6e4b80f9] BenchmarkTools v1.3.2
  [336ed68f] CSV v0.10.9
  [a93c6f00] DataFrames v1.4.4
⌃ [2b5f629d] DiffEqBase v6.114.1
  [0c46a032] DifferentialEquations v7.6.0
  [31c24e10] Distributions v0.25.80
  [f6369f11] ForwardDiff v0.10.34
  [6fdf6af0] LogDensityProblems v2.1.0
  [996a588d] LogDensityProblemsAD v1.1.1
  [429524aa] Optim v1.7.4
  [c46f51b8] ProfileView v1.5.2
  [37e2e3b7] ReverseDiff v1.14.4 `https://github.com/torfjelde/ReverseDiff.jl#torfjelde/sort-of-support-non-linear-indexing`
  [0bca4576] SciMLBase v1.81.0
⌃ [1ed8b502] SciMLSensitivity v7.17.1
  [f3b207a7] StatsPlots v0.15.4
  [fce5fe82] Turing v0.24.0
  [0db1332d] TuringBenchmarking v0.1.1
  [e88e6eb3] Zygote v0.6.55
Info Packages marked with ⌃ have new versions available and may be upgradable.
</pre>

<p>
Download and install dependencies
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>]instantiate
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Before-we-begin-split">

<p>
And finally, do
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> GeiloWinterSchool2023Part2
</code></pre>
</div>

<p>
to get some functionality I've implemented for the occasion
</p>

</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy">
<h2 id="2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy">The story of a little Norwegian boy</h2>
</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
There once was a little Norwegian boy
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-18_14-49-24_471337_3317365246956_1262712540_o.jpg" alt="2023-01-18_14-49-24_471337_3317365246956_1262712540_o.jpg" height="400px" />
</p>
</div>


</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
When this little boy was 20 years old, he was working as a parking guard near Preikestolen/Pulpit rock
</p>



<div class="figure">
<p><img src="assets/attachments/2023-01-18_14-57-08_Preikestolen-plateau-Go-Fjords-Bob-Engelsen-P1026771_kljg5o.jpeg" alt="2023-01-18_14-57-08_Preikestolen-plateau-Go-Fjords-Bob-Engelsen-P1026771_kljg5o.jpeg" height="400px" />
</p>
</div>


</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
One day it was raining and there was nobody hiking, and so there was no cars in sight for the little boy to point
</p>

<div class="fragment (appear)">

<p>
When his boss wasn't looking, the little 20 year-old boy had an amazing idea
</p>

<blockquote >
<p>
Maybe I can use this method of Mr. Bayes I learned a bit about yesteday to model football / Premier League?
</p>
</blockquote>

</div>

<p class="fragment (appear)">
The little boy got very excited and started looking for stuff on the big interwebs
</p>

</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
The little boy came across this
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-18_14-46-02_Screenshot_20230118_144454.png" alt="2023-01-18_14-46-02_Screenshot_20230118_144454.png" />
</p>
</div>

<p>
And got <span class="underline">very</span> excited
</p>

</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
But at the time, the little boy knew next to <span class="underline">nothing</span> about programming
</p>

<p>
The little boy couldn't write the code to do the inference
</p>

<p class="fragment (appear)">
Whence the little boy became a <span class="underline">sad</span> little boy :(
</p>

</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
But time heals all wounds, and at some point the little boy learned Python
</p>

<p>
And in Python, the boy found the <i>probabilistic programming language</i> <code>pymc3</code>
</p>

<div class="fragment (appear)">
<blockquote >
<p>
Maybe I can use <code>pymc3</code> to perform inference in that football / Premier League model?
</p>
</blockquote>

<p>
And so the sad boy once more became an <span class="underline">excited</span> little boy :)
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
But there was a problem
</p>

<p>
The boy wanted to write a for-loop in his model, but the model didn't want it to be so and complained!
</p>

<p class="fragment (appear)">
The boy got frustrated and gave up, once more becoming a <span class="underline">sad</span> little boy :(
</p>

<div class="small-text">

<p class="fragment (appear)">
The boy should have known that the computational backend <code>theano</code> that was used by <code>pymc3</code> at the time couldn't handle a for-loop, and instead he should have used <code>scan</code>. But the boy was only 20-something years old; he didn't know.
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-The-story-of-a-little-Norwegian-boy-split">

<p>
Some years later the boy discovers a programming language called <span class="underline">Julia</span>
</p>

<div class="fragment (appear)">
<p>
Julia makes a few promises
</p>
<ol>
<li class="fragment appear">It's fast. Like <i>really</i> fast.</li>
<li class="fragment appear">It's interactive; doesn't require full compilation for you to play with it.</li>
<li class="fragment appear">You don't have to specify types everywhere.</li>

</ol>
</div>

<div class="fragment (appear)">
<p>
The boy thinks
</p>

<blockquote >
<p>
Wait, but this sounds like Python but the only difference is that&#x2026;I CAN WRITE FOR-LOOPS WITHOUT FEELING BAD ABOUT IT?!
</p>
</blockquote>

<p>
Yes, yes he could
</p>

<p class="fragment (appear)">
And 3.5 years later, he's still writing for-loops. Well, sort of.
</p>
</div>
</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Why-Turing-dot-jl">
<h2 id="2023-01-29-16-57-28-Why-Turing-dot-jl">Why Turing.jl?</h2>
</section>
<section id="slide-2023-01-29-16-57-28-Why-Turing-dot-jl-split">

<p>
Duh, you should use Turing.jl <span class="underline">so you get to use Julia</span>
</p>

<div class="fragment (appear)">

<p>
But even in Julia, other PPLS exist
</p>

<p>
But Turing.jl is very similar to Julia in "philosophy":
</p>
<ul>
<li>Flexiblility</li>
<li>Ease-of-use</li>
<li>Speed (potentially with a bit of effort)</li>

</ul>

<p>
So it's a pretty good candidate
</p>

</div>
</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Running-example">
<h2 id="2023-01-29-16-57-28-Running-example">Running example</h2>
<p>
We'll work with an outbreak of influenza A (H1N1) in 1978 at a British boarding school
</p>

<ul>
<li>763 male students -&gt; 512 of which became ill</li>
<li>Reported that one infected boy started the epidemic</li>
<li>Observations are number of boys in bed over 14 days</li>

</ul>

<p>
Data are freely available in the R package <code>outbreaks</code>, maintained as part of the <a href="http://www.repidemicsconsortium.org/">R Epidemics Consortium</a>
</p>

<div class="fragment (appear)">

<p>
Data + part of the analysis is <i>heavily</i> inspired by <a href="https://mc-stan.org/users/documentation/case-studies/boarding_school_case_study.html">https://mc-stan.org/users/documentation/case-studies/boarding_school_case_study.html</a>
</p>

<p>
Stan definitively beats Turing.jl when it comes to great write-ups like these
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Loading-into-Julia">
<h3 id="2023-01-29-16-57-28-Loading-into-Julia">Loading into Julia</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Load the dataframe.</span>
<span style="color: #3B6EA8;">using</span> Dates
<span style="color: #3B6EA8;">using</span> DataFrames, CSV

N = 763
data = DataFrame(CSV.File(joinpath(<span style="color: #4F894C;">"data"</span>, <span style="color: #4F894C;">"influenza_england_1978_school.csv"</span>)));
print(data)
</code></pre>
</div>

<pre class="example">
14×4 DataFrame
 Row │ Column1  date        in_bed  convalescent 
     │ Int64    Date        Int64   Int64        
─────┼───────────────────────────────────────────
   1 │       1  1978-01-22       3             0
   2 │       2  1978-01-23       8             0
   3 │       3  1978-01-24      26             0
   4 │       4  1978-01-25      76             0
   5 │       5  1978-01-26     225             9
   6 │       6  1978-01-27     298            17
   7 │       7  1978-01-28     258           105
   8 │       8  1978-01-29     233           162
   9 │       9  1978-01-30     189           176
  10 │      10  1978-01-31     128           166
  11 │      11  1978-02-01      68           150
  12 │      12  1978-02-02      29            85
  13 │      13  1978-02-03      14            47
  14 │      14  1978-02-04       4            20
</pre>

<p>
Notice that each of the columns have associated types
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Loading-into-Julia-split">

<p>
Let's visualize the samples:
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> StatsPlots
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">StatsPlots.jl provides this convenient macro `@df` for plotting a `DataFrame`.</span>
<span style="color: #3B6EA8; font-weight: bold;">@df</span> data scatter(<span style="color: #97365B;">:date</span>, <span style="color: #97365B;">:in_bed</span>, label=<span style="color: #97365B;">nothing</span>, ylabel=<span style="color: #4F894C;">"Number of students in bed"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/1265078e6dd1a955c2c437e28a8d0d0904467ad2.png" alt="1265078e6dd1a955c2c437e28a8d0d0904467ad2.png" />
</p>
</div>

</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Differential-equations">
<h2 id="2023-01-29-16-57-28-Differential-equations">Differential equations</h2>
</section>
<section id="slide-2023-01-29-16-57-28-Differential-equations-split">

<p>
Suppose we have some function \(f\) which describes how a state \(x\) evolves wrt. \(t\)
</p>
<div>
\begin{equation*}
\frac{\mathrm{d} x}{\mathrm{d} t} = f(x, t)
\end{equation*}

</div>
<p>
which we then need to integrate to obtain the actual state at some time \(t\)
</p>
<div>
\begin{equation*}
x(t) = \int_{0}^{t} \frac{\mathrm{d} x}{\mathrm{d} t} \mathrm{d} t = \int_{0}^{t} f(x, t) \mathrm{d} t
\end{equation*}

</div>

<p>
In many interesting scenarios numerical methods are required to obtain \(x(t)\)
</p>

</section>
<section id="slide-2023-01-29-16-57-28-In-Julia">
<h3 id="2023-01-29-16-57-28-In-Julia">In Julia</h3>
<p>
Everything related to differential equations is provided by <a href="https://docs.sciml.ai/DiffEqDocs/stable/"><code>DifferentialEquations.jl</code></a>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-In-Julia-split">

<p>
And I really do mean <a href="https://docs.sciml.ai/DiffEqDocs/stable/"><i>everything</i></a>
</p>

<div class="side-by-side">


<div class="figure">
<p><img src="assets/attachments/2023-01-19_19-48-23_Screenshot_20230119_194737.png" alt="2023-01-19_19-48-23_Screenshot_20230119_194737.png" />
</p>
</div>


<div class="figure">
<p><img src="assets/attachments/2023-01-19_19-48-41_Screenshot_20230119_194838.png" alt="2023-01-19_19-48-41_Screenshot_20230119_194838.png" />
</p>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model">
<h3 id="2023-01-29-16-57-28-Example-SIR-model">Example: SIR model</h3>
<p>
One particular example of an (ordinary) differential equation that you might have seen recently is the <b>SIR model</b> used in epidemiology
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-19_19-56-00_sir_illu.png" alt="2023-01-19_19-56-00_sir_illu.png" />
</p>
<p><span class="figure-number">Figure 7: </span><a href="https://covid19.uclaml.org/model.html">https://covid19.uclaml.org/model.html</a> (2023-01-19)</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
The temporal dynamics of the sizes of each of the compartments are governed by the following system of ODEs:
</p>
<div>
\begin{equation*}
\begin{split}
  \frac{\mathrm{d} S}{\mathrm{d} t} &= - \beta S \frac{I}{N} \\
  \frac{\mathrm{d} I}{\mathrm{d} t} &= \beta S \frac{I}{N} - \gamma I \\
  \frac{\mathrm{d} R}{\mathrm{d} t} &= \gamma I
\end{split}
\end{equation*}

</div>
<p>
where
</p>
<ul>
<li>\(S(t)\) is the number of people susceptible to becoming infected,</li>
<li>\(I(t)\) is the number of people currently infected,</li>
<li>\(R(t)\) is the number of recovered people,</li>
<li>\(β\) is the constant rate of infectious contact between people,</li>
<li>\(\gamma\) the constant recovery rate of infected individuals</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
Converting this ODE into code is just
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> DifferentialEquations

<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SIR!</span>(
    du,  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">buffer for the updated differential equation</span>
    u,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current state</span>
    p,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">parameters</span>
    t    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current time</span>
)
    N = 763  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">population</span>
    S, I, R = u
    &#946;, &#947; = p

    du[1] = dS = -&#946; * I * S / N
    du[2] = dI = &#946; * I * S / N - &#947; * I
    du[3] = dR = &#947; * I
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
SIR! (generic function with 1 method)
</pre>


<p>
Not too bad!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
Initial conditions are then
</p>
<div>
\begin{equation*}
\begin{split}
  S(0) &= N - 1 \\
  I(0) &= 1 \\
  R(0) &= 0
\end{split}
\end{equation*}

</div>
<p>
and we want to integrate from \(t = 0\) to \(t = 14\)
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Include 0 because that's the initial condition before any observations.</span>
tspan = (0.0, 14.0)

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Initial conditions are:</span>
<span style="color: #8b94a5;">#   </span><span style="color: #8b94a5;">S(0) = N - 1; I(0) = 1; R(0) = 0</span>
u0 = [N - 1, 1, 0.0]
</code></pre>
</div>

<pre class="example">
3-element Vector{Float64}:
 762.0
   1.0
   0.0
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
Now we just need to define the overall problem and we can solve:
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Just to check that everything works, we'll just use some "totally random" values for &#946; and &#947;:</span>
problem_sir = <span style="color: #3B6EA8;">let</span> &#946; = 2.0, &#947; = 0.6
    ODEProblem(SIR!, u0, tspan, (&#946;, &#947;))
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
ODEProblem with uType Vector{Float64} and tType Float64. In-place: true
timespan: (0.0, 14.0)
u0: 3-element Vector{Float64}:
 762.0
   1.0
   0.0
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
Aaaand
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sol = solve(problem_sir)
</code></pre>
</div>

<pre class="example">
retcode: Success
Interpolation: specialized 4th order "free" interpolation, specialized 2nd order "free" stiffness-aware interpolation
t: 23-element Vector{Float64}:
  0.0
  0.0023558376404244326
  0.025914214044668756
  0.11176872871946908
  0.26714420676761075
  0.47653584778586056
  0.7436981238065388
  1.0701182881347182
  1.4556696154809898
  1.8994815718103506
  2.4015425820305163
  2.9657488203418048
  3.6046024613854746
  4.325611232479916
  5.234036476235002
  6.073132270491685
  7.323851265223563
  8.23100744184026
  9.66046960467715
 11.027717843180652
 12.506967592177675
 13.98890399536329
 14.0
u: 23-element Vector{Vector{Float64}}:
 [762.0, 1.0, 0.0]
 [761.9952867607622, 1.003297407481751, 0.001415831756055325]
 [761.9472927630898, 1.036873767352754, 0.015833469557440357]
 [761.7584189579304, 1.1690001128296739, 0.0725809292398516]
 [761.353498610305, 1.4522140137552049, 0.19428737593979384]
 [760.6490369821046, 1.9447820690728455, 0.4061809488225752]
 [759.3950815454128, 2.8210768113583082, 0.7838416432288186]
 [757.0795798160242, 4.437564277195732, 1.4828559067800167]
 [752.6094742865345, 7.552145919430467, 2.8383797940350495]
 [743.573784947305, 13.823077731564027, 5.603137321131049]
 [724.5575481927715, 26.909267078762316, 11.533184728466205]
 [683.6474029897502, 54.51612001957392, 24.836476990675976]
 [598.1841629858786, 109.41164143668018, 55.40419557744127]
 [450.08652743810205, 192.396449154863, 120.51702340703504]
 [259.11626253270623, 256.9925778114915, 246.89115965580237]
 [148.3573731526537, 240.10301213899098, 374.53961470835543]
 [76.52998017846475, 160.6373332952353, 525.8326865263001]
 [55.70519994004921, 108.7634182279299, 598.531381832021]
 [41.39587834423381, 55.09512088924873, 666.5090007665176]
 [35.87067243374374, 27.821838135708532, 699.3074894305479]
 [33.252184333490774, 13.087185981359177, 716.6606296851502]
 [32.08996839417716, 6.105264616193066, 724.8047669896299]
 [32.08428686823946, 6.070415830241046, 724.8452973015196]
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
We didn't specify a solver
</p>

<p>
DifferentialEquations.jl uses <code>AutoTsit5(Rosenbrock32())</code> by default 
</p>

<p>
Which is a composition between
</p>

<ul>
<li><code>Tsit5</code> (4th order Runge-Kutta), and</li>
<li><code>Rosenbrock32</code> (3rd order stiff solver)</li>

</ul>

<p>
with automatic switching between the two
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
<code>AutoTsit5(Rosenbrock32())</code> covers many use-cases well, but see
</p>

<ul>
<li><a href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/">https://docs.sciml.ai/DiffEqDocs/stable/solvers/ode_solve/</a></li>
<li><a href="https://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/">https://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/</a></li>

</ul>

<p>
for more info on choosing a solver
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
This is the resulting solution
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(
    sol,
    linewidth=2, xaxis=<span style="color: #4F894C;">"Time in days"</span>, label=[<span style="color: #4F894C;">"Suspectible"</span> <span style="color: #4F894C;">"Infected"</span> <span style="color: #4F894C;">"Recovered"</span>],
    alpha=0.5, size=(500, 300)
)
scatter!(1:14, data.in_bed, label=<span style="color: #4F894C;">"Data"</span>, color=<span style="color: #4F894C;">"black"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/780e8cc1c00812abcfba1fe711f0a8b7b168b7e7.png" alt="780e8cc1c00812abcfba1fe711f0a8b7b168b7e7.png" />
</p>
</div>

<p>
This doesn't really match the data though; let's do better
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
Approach #1: find optimal values of \(\beta\) and \(\gamma\) by minimizing some loss, e.g. sum-of-squares
</p>

<div>
\begin{equation*}
\ell(\beta, \gamma) = \sum_{i = 1}^{14} \bigg( F(u_0, t_i;\ \beta, \gamma) - y_i \bigg)^2
\end{equation*}

</div>

<p>
where \(\big( y_i \big)_{i = 1}^{14}\) are the observations, \(F\) is the integrated system
</p>

<div class="fragment (appear)">

<p>
First we define the loss
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Define the loss function.</span>
<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">loss_sir</span>(problem_orig, p)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">`remake` just, well, remakes the `problem` with `p` replaced.</span>
    problem = remake(problem_orig, p=p)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">To ensure we get solutions _exactly_ at the timesteps of interest,</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">i.e. every day we have observations, we use `saveat=1` to tell `solve`</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">to save at every timestep (which is one day).</span>
    sol = solve(problem, saveat=1)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Extract the 2nd state, the (I)infected, for the dates with observations.</span>
    sol_for_observed = sol[2, 2:15]
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Compute the sum-of-squares of the infected vs. data.</span>
    sum(abs2.(sol_for_observed - data.in_bed))
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
loss_sir (generic function with 1 method)
</pre>


</div>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
And the go-to for optimization in Julia is <a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> Optim
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">An alternative to writing `y -&gt; f(x, y)` is `Base.Fix1(f, x)` which</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">avoids potential performance issues with global variables (as our `problem` here).</span>
opt = optimize(
    p -&gt; loss_sir(problem_sir, p), <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">function to minimize</span>
    [0, 0],                <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">lower bounds on variables</span>
    [<span style="color: #97365B;">Inf</span>, <span style="color: #97365B;">Inf</span>],            <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">upper bounds on variables</span>
    [2.0, 0.5],            <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">initial values</span>
    Fminbox(NelderMead())  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">optimization alg</span>
) 
</code></pre>
</div>

<pre class="example">
* Status: success

* Candidate solution
   Final objective value:     4.116433e+03

* Found with
   Algorithm:     Fminbox with Nelder-Mead

* Convergence measures
   |x - x'|               = 0.00e+00 ≤ 0.0e+00
   |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00
   |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00
   |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00
   |g(x)|                 = 7.86e+04 ≰ 1.0e-08

* Work counters
   Seconds run:   2  (vs limit Inf)
   Iterations:    4
   f(x) calls:    565
   ∇f(x) calls:   1
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<p>
We can extract the minimizers of the loss
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>&#946;, &#955; = Optim.minimizer(opt)
&#946;, &#955;
</code></pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">1.6692320164955483</td>
<td class="org-right">0.44348639177622445</td>
</tr>
</tbody>
</table>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SIR-model-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve for the obtained parameters.</span>
problem_sir = remake(problem_sir, p=(&#946;, &#955;))
sol = solve(problem_sir)

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Plot the solution.</span>
plot(sol, linewidth=2, xaxis=<span style="color: #4F894C;">"Time in days"</span>, label=[<span style="color: #4F894C;">"Suspectible"</span> <span style="color: #4F894C;">"Infected"</span> <span style="color: #4F894C;">"Recovered"</span>], alpha=0.5)
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">And the data.</span>
scatter!(1:14, data.in_bed, label=<span style="color: #4F894C;">"Data"</span>, color=<span style="color: #4F894C;">"black"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/6326dbbbf15b88051f47afcbeb63f6b3c64accd5.png" alt="6326dbbbf15b88051f47afcbeb63f6b3c64accd5.png" />
</p>
</div>

<p>
That's better than our <i>totally</i> "random" guess from earlier!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Example-SEIR-model">
<h3 id="2023-01-29-16-57-28-Example-SEIR-model">Example: SEIR model</h3>
<p>
Adding another compartment to our SIR model: the <span class="underline">(E)xposed</span> state
</p>

<div>
\begin{equation*}
\begin{split}
  \frac{\mathrm{d} S}{\mathrm{d} t} &= - \beta S \frac{I}{N} \\
  \frac{\mathrm{d} {\color{blue} E}}{\mathrm{d} t} &= \beta S \frac{I}{N} - {\color{orange} \sigma} {\color{blue} E} \\
  \frac{\mathrm{d} I}{\mathrm{d} t} &= {\color{orange} \sigma} {\color{blue} E} - \gamma I \\
  \frac{\mathrm{d} R}{\mathrm{d} t} &= \gamma I
\end{split}
\end{equation*}

</div>

<p>
where we've added a new parameter \({\color{orange} \sigma}\) describing the fraction of people who develop observable symptoms in this time
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia">
<h3 id="2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia"><span class="todo TASK">TASK</span> Solve the SEIR model using Julia</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SEIR!</span>(
    du,  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">buffer for the updated differential equation</span>
    u,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current state</span>
    p,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">parameters</span>
    t    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current time</span>
)
    N = 763  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">population</span>

    S, E, I, R = u  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">have ourselves an additional state!</span>
    &#946;, &#947;, &#963; = p     <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">and an additional parameter!</span>

    <span style="color: #8b94a5;"># </span><span style="color: #9A7500; font-weight: bold;">TODO:</span><span style="color: #8b94a5;"> Implement yah fool!</span>
    du[1] = <span style="color: #97365B;">nothing</span>
    du[2] = <span style="color: #97365B;">nothing</span>
    du[3] = <span style="color: #97365B;">nothing</span>
    du[4] = <span style="color: #97365B;">nothing</span>
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<p>
<b>BONUS:</b> Use <code>Optim.jl</code> to find minimizers of sum-of-squares
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia">
<h3 id="2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia"><span class="done SOLUTION">SOLUTION</span> Solve the SEIR model using Julia</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SEIR!</span>(
    du,  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">buffer for the updated differential equation</span>
    u,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current state</span>
    p,   <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">parameters</span>
    t    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">current time</span>
)
    N = 763  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">population</span>
    S, E, I, R = u  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">have ourselves an additional state!</span>
    &#946;, &#947;, &#963; = p     <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">and an additional parameter!</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Might as well cache these computations.</span>
    &#946;SI = &#946; * S * I / N
    &#963;E = &#963; * E
    &#947;I = &#947; * I

    du[1] = -&#946;SI
    du[2] = &#946;SI - &#963;E
    du[3] = &#963;E - &#947;I
    du[4] = &#947;I
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
SEIR! (generic function with 1 method)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>problem_seir = <span style="color: #3B6EA8;">let</span> u0 = [N - 1, 0, 1, 0], &#946; = 2.0, &#947; = 0.6, &#963; = 0.8
    ODEProblem(SEIR!, u0, tspan, (&#946;, &#947;, &#963;))
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
ODEProblem with uType Vector{Int64} and tType Float64. In-place: true
timespan: (0.0, 14.0)
u0: 4-element Vector{Int64}:
 762
   0
   1
   0
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sol_seir = solve(problem_seir, saveat=1)
</code></pre>
</div>

<pre class="example">
retcode: Success
Interpolation: 1st order linear
t: 15-element Vector{Float64}:
  0.0
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0
 10.0
 11.0
 12.0
 13.0
 14.0
u: 15-element Vector{Vector{Float64}}:
 [762.0, 0.0, 1.0, 0.0]
 [760.1497035901518, 1.277915971753478, 1.0158871356490553, 0.5564933024456415]
 [757.5476928906271, 2.425869618233348, 1.6850698824327135, 1.341367608706787]
 [753.081189706403, 4.277014534677882, 2.9468385687120784, 2.6949571902067637]
 [745.3234082630842, 7.455598293492679, 5.155811621098981, 5.065181822323938]
 [731.9851682751213, 12.855816151849933, 8.960337047554939, 9.198678525473571]
 [709.5042941973462, 21.77178343781762, 15.384985521594787, 16.338936843241182]
 [672.8733895183619, 35.77263271085456, 25.88133104438007, 28.472646726403138]
 [616.390571176038, 55.97177756967422, 42.09614416178476, 48.54150709250279]
 [536.453596476594, 81.2428045994271, 64.9673325777641, 80.33626634621449]
 [436.43708330634297, 106.04037246704702, 92.9550757379631, 127.56746848864664]
 [329.60092931771436, 121.08020372279418, 120.48402926084937, 191.83483769864185]
 [233.8471941518982, 119.43669383157659, 139.3233304893263, 270.3927815271987]
 [160.88805352426687, 102.7399386960996, 143.3826208089892, 355.9893869706441]
 [111.72261866282292, 79.02493776169311, 132.78384886713565, 439.46859470834806]
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(sol_seir, linewidth=2, xaxis=<span style="color: #4F894C;">"Time in days"</span>, label=[<span style="color: #4F894C;">"Suspectible"</span> <span style="color: #4F894C;">"Exposed"</span> <span style="color: #4F894C;">"Infected"</span> <span style="color: #4F894C;">"Recovered"</span>], alpha=0.5)
scatter!(1:14, data.in_bed, label=<span style="color: #4F894C;">"Data"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/34a52974b7bc0320bef1eb49f39ea8875566a0b3.png" alt="34a52974b7bc0320bef1eb49f39ea8875566a0b3.png" />
</p>
</div>

<p>
Don't look so good. Let's try Optim.jl again.
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">loss_seir</span>(problem, p)
    problem = remake(problem, p=p)
    sol = solve(problem, saveat=1)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> 3rd state is now the (I)nfectious compartment!!!</span>
    sol_for_observed = sol[3, 2:15]
    <span style="color: #3B6EA8;">return</span> sum(abs2.(sol_for_observed - data.in_bed))
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
loss_seir (generic function with 1 method)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>opt = optimize(Base.Fix1(loss_seir, problem_seir), [0, 0, 0], [<span style="color: #97365B;">Inf</span>, <span style="color: #97365B;">Inf</span>, <span style="color: #97365B;">Inf</span>], [2.0, 0.5, 0.9], Fminbox(NelderMead()))
</code></pre>
</div>

<pre class="example">
* Status: success (reached maximum number of iterations)

* Candidate solution
   Final objective value:     3.115978e+03

* Found with
   Algorithm:     Fminbox with Nelder-Mead

* Convergence measures
   |x - x'|               = 0.00e+00 ≤ 0.0e+00
   |x - x'|/|x'|          = 0.00e+00 ≤ 0.0e+00
   |f(x) - f(x')|         = 0.00e+00 ≤ 0.0e+00
   |f(x) - f(x')|/|f(x')| = 0.00e+00 ≤ 0.0e+00
   |g(x)|                 = 1.77e+05 ≰ 1.0e-08

* Work counters
   Seconds run:   1  (vs limit Inf)
   Iterations:    3
   f(x) calls:    13259
   ∇f(x) calls:   1
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>&#946;, &#947;, &#963; = Optim.minimizer(opt)
</code></pre>
</div>

<pre class="example">
3-element Vector{Float64}:
 4.853872993924619
 0.4671485850111774
 0.8150294098438762
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sol_seir = solve(remake(problem_seir, p=(&#946;, &#947;, &#963;)), saveat=1)
plot(sol_seir, linewidth=2, xaxis=<span style="color: #4F894C;">"Time in days"</span>, label=[<span style="color: #4F894C;">"Suspectible"</span> <span style="color: #4F894C;">"Exposed"</span> <span style="color: #4F894C;">"Infected"</span> <span style="color: #4F894C;">"Recovered"</span>], alpha=0.5)
scatter!(1:14, data.in_bed, label=<span style="color: #4F894C;">"Data"</span>, color=<span style="color: #4F894C;">"black"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/62ee261fb15aead33e6f49e82e01a7482b56017f.png" alt="62ee261fb15aead33e6f49e82e01a7482b56017f.png" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Solve-the-SEIR-model-using-Julia-split">

<blockquote >
<p>
But&#x2026;but these are <span class="underline">point estimates</span>! What about distributions? WHAT ABOUT UNCERTAINTY?!
</p>
</blockquote>

<p>
No, no that's fair.
</p>

<p>
Let's do some Bayesian inference then.
</p>

<p>
BUT FIRST!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Making-our-future-selves-less-annoyed">
<h3 id="2023-01-29-16-57-28-Making-our-future-selves-less-annoyed">Making our future selves less annoyed</h3>
<p>
It's annoying to have all these different loss-functions for <i>both</i> <code>SIR!</code> and <code>SEIR!</code>
</p>

<div class="fragment (appear)">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Abstract type which we can use to dispatch on.</span>
<span style="color: #3B6EA8;">abstract type</span> <span style="color: #9A7500;">AbstractEpidemicProblem</span> <span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8;">struct</span> <span style="color: #9A7500;">SIRProblem</span>{P} &lt;: <span style="color: #9A7500;">AbstractEpidemicProblem</span>
    problem::<span style="color: #9A7500;">P</span>
    N::<span style="color: #9A7500;">Int</span>
<span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SIRProblem</span>(N::<span style="color: #9A7500;">Int</span>; u0 = [N - 1, 1, 0.], tspan = (0, 14), p = [2.0, 0.6])
    <span style="color: #3B6EA8;">return</span> SIRProblem(ODEProblem(SIR!, u0, tspan, p), N)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
SIRProblem
</pre>


<p>
Then we can just construct the problem as
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sir = SIRProblem(N);
</code></pre>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Making-our-future-selves-less-annoyed-split">

<p>
And to make it a bit easier to work with, we add some utility functions
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">General.</span>
<span style="color: #29838D;">parameters</span>(prob::<span style="color: #9A7500;">AbstractEpidemicProblem</span>) = prob.problem.p
<span style="color: #29838D;">initial_state</span>(prob::<span style="color: #9A7500;">AbstractEpidemicProblem</span>) = prob.problem.u0
<span style="color: #29838D;">population</span>(prob::<span style="color: #9A7500;">AbstractEpidemicProblem</span>) = prob.N

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Specializations.</span>
<span style="color: #29838D;">susceptible</span>(::<span style="color: #9A7500;">SIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[1, :]
<span style="color: #29838D;">infected</span>(::<span style="color: #9A7500;">SIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[2, :]
<span style="color: #29838D;">recovered</span>(::<span style="color: #9A7500;">SIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[3, :]
</code></pre>
</div>

<pre class="example">
recovered (generic function with 2 methods)
</pre>


<p>
So that once we've solved the problem, we can easily extract the compartment we want, e.g.
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sol = solve(sir.problem, saveat=1)
infected(sir, sol)
</code></pre>
</div>

<pre class="example">
15-element Vector{Float64}:
   1.0
   4.026799533924021
  15.824575905720002
  56.779007685250534
 154.4310579906169
 248.98982384839158
 243.67838619968524
 181.93939659551987
 120.64627375763271
  75.92085282572398
  46.58644927641269
  28.214678599716418
  16.96318676577873
  10.158687874394722
   6.070415830241046
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Implement-SEIRProblem">
<h3 id="2023-01-29-16-57-28-Implement-SEIRProblem"><span class="todo TASK">TASK</span> Implement <code>SEIRProblem</code></h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">struct</span> <span style="color: #9A7500;">SEIRProblem</span> &lt;: <span style="color: #9A7500;">AbstractEpidemicProblem</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">...</span>
<span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SEIRProblem</span> <span style="color: #3B6EA8;">end</span>

susceptible
exposed
infected
recovered
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Implement-SEIRProblem">
<h3 id="2023-01-29-16-57-28-Implement-SEIRProblem"><span class="done SOLUTION">SOLUTION</span> Implement <code>SEIRProblem</code></h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">struct</span> <span style="color: #9A7500;">SEIRProblem</span>{P} &lt;: <span style="color: #9A7500;">AbstractEpidemicProblem</span>
    problem::<span style="color: #9A7500;">P</span>
    N::<span style="color: #9A7500;">Int</span>
<span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">SEIRProblem</span>(N::<span style="color: #9A7500;">Int</span>; u0 = [N - 1, 0, 1, 0.], tspan = (0, 14), p = [4.5, 0.45, 0.8])
    <span style="color: #3B6EA8;">return</span> SEIRProblem(ODEProblem(SEIR!, u0, tspan, p), N)
<span style="color: #3B6EA8;">end</span>

<span style="color: #29838D;">susceptible</span>(::<span style="color: #9A7500;">SEIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[1, :]
<span style="color: #29838D;">exposed</span>(::<span style="color: #9A7500;">SEIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[2, :]
<span style="color: #29838D;">infected</span>(::<span style="color: #9A7500;">SEIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[3, :]
<span style="color: #29838D;">recovered</span>(::<span style="color: #9A7500;">SEIRProblem</span>, u::<span style="color: #9A7500;">AbstractMatrix</span>) = u[4, :]
</code></pre>
</div>

<pre class="example">
recovered (generic function with 2 methods)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Implement-SEIRProblem-split">

<p>
Now, given a <code>problem</code> and a <code>sol</code>, we can query the <code>sol</code> for the <code>infected</code> state without explicit handling of which <code>problem</code> we're working with
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>seir = SEIRProblem(N);
sol = solve(seir.problem, saveat=1)
infected(seir, sol)
</code></pre>
</div>

<pre class="example">
15-element Vector{Float64}:
   1.0
   1.9941817088874336
   6.958582307202902
  23.9262335176065
  74.23638542794971
 176.98368495653585
 276.06126059898344
 293.92632518571605
 249.92836195453708
 189.07578975511504
 134.2373192679034
  91.82578430804273
  61.38108478932363
  40.42264366743211
  26.357816296754425
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Same-loss-for-both">
<h3 id="2023-01-29-16-57-28-Same-loss-for-both">Same <code>loss</code> for both!</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">loss</span>(problem_wrapper::<span style="color: #9A7500;">AbstractEpidemicProblem</span>, p)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Extract the `problem` from `problem_wrapper`.</span>
    problem = remake(problem_wrapper.problem, p=p)
    sol = solve(problem, saveat=1)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Now this is completely general!</span>
    sol_for_observed = infected(problem_wrapper, sol)[2:<span style="color: #3B6EA8;">end</span>]
    <span style="color: #3B6EA8;">return</span> sum(abs2.(sol_for_observed - data.in_bed))
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
loss (generic function with 1 method)
</pre>


<p>
Now we can call the same <code>loss</code> for both <code>SIR</code> and <code>SEIR</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>loss(SIRProblem(N), [2.0, 0.6])
</code></pre>
</div>

<pre class="example">
50257.83978134881
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>loss(SEIRProblem(N), [2.0, 0.6, 0.8])
</code></pre>
</div>

<pre class="example">
287325.105532706
</pre>

</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference">
<h2 id="2023-01-29-16-57-28-Bayesian-inference">Bayesian inference</h2>
</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
First off
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> Turing
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
This dataset really doesn't have too many observations
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>nrow(data)
</code></pre>
</div>

<pre class="example">
14
</pre>


<p>
So reporting a single number for parameters is maybe being a <i>bit</i> too confident
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
We'll use the following model
</p>
<div>
\begin{equation*}
\begin{split}
  \beta &\sim \mathcal{N}_{ + }(2, 1) \\
  \gamma &\sim \mathcal{N}_{ + }(0.4, 0.5) \\
  \phi^{-1} &\sim \mathrm{Exponential}(1/5) \\
   y_i &\sim \mathrm{NegativeBinomial2}\big(F(u_0, t_i;\ \beta, \gamma), \phi \big)
\end{split}
\end{equation*}

</div>
<p>
where 
</p>
<ul>
<li>\(\big( y_i \big)_{i = 1}^{14}\) are the observations,</li>
<li>\(F\) is the integrated system, and</li>
<li>\(\phi\) is the over-dispersion parameter.</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(
    plot(truncated(Normal(2, 1); lower=0), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#946;"</span>),
    plot(truncated(Normal(0.4, 0.5); lower=0), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#947;"</span>),
    plot(Exponential(1/5), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#981;&#8315;&#185;"</span>),
    layout=(3, 1)
)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/80c76ad5d3151ec0f3e044a075b2a5b88956d14b.png" alt="80c76ad5d3151ec0f3e044a075b2a5b88956d14b.png" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
A <code>NegativeBinomial(r, p)</code> represents the number of trials to achieve \(r\) successes, where each trial has a probability \(p\) of success
</p>

<p>
A <code>NegativeBinomial2(μ, ϕ)</code> is the same, but parameterized using the mean \(μ\) and <i>dispersion</i> \(\phi\)
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">`NegativeBinomial` already exists, so let's just make an alternative constructor instead.</span>
<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">NegativeBinomial2</span>(&#956;, &#981;)
    p = 1/(1 + &#956;/&#981;)
    r = &#981;
    <span style="color: #3B6EA8;">return</span> NegativeBinomial(r, p)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
NegativeBinomial2 (generic function with 1 method)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Let's just make sure we didn't do something stupid.</span>
&#956; = 2; &#981; = 3;
dist = NegativeBinomial2(&#956;, &#981;)
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Source: https://mc-stan.org/docs/2_20/functions-reference/nbalt.html</span>
mean(dist) &#8776; &#956; &amp;&amp; var(dist) &#8776; &#956; + &#956;^2 / &#981;
</code></pre>
</div>

<pre class="example">
true
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
Can be considered a generalization of <code>Poisson</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>&#956; = 2.0
anim = <span style="color: #3B6EA8; font-weight: bold;">@animate</span> <span style="color: #3B6EA8;">for</span> &#981; <span style="color: #3B6EA8;">&#8712;</span> [0.1, 0.5, 1.0, 2.0, 5.0, 10.0, 25.0, 100.0]
    p = plot(size=(500, 300))
    plot!(p, Poisson(&#956;); label=<span style="color: #4F894C;">"Poisson($&#956;)"</span>)
    plot!(p, NegativeBinomial2(&#956;, &#981;), label=<span style="color: #4F894C;">"NegativeBinomial2($&#956;, $&#981;)"</span>)
    xlims!(0, 20); ylims!(0, 0.35);
    p
<span style="color: #3B6EA8;">end</span>
gif(anim, <span style="color: #4F894C;">"negative_binomial.gif"</span>, fps=2);
</code></pre>
</div>

<pre class="example">
[ Info: Saved animation to /home/tor/Projects/public/Turing-Workshop/2023-Geilo-Winter-School/Part-2-Turing-and-other-things/negative_binomial.gif
</pre>



<div class="figure">
<p><img src="./negative_binomial.gif" alt="negative_binomial.gif" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> sir_model(
    num_days;                                  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Number of days to model</span>
    tspan = (0.0, float(num_days)),            <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Timespan to model</span>
    u0 = [N - 1, 1, 0.0],                      <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Initial state</span>
    p0 = [2.0, 0.6],                           <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Placeholder parameters</span>
    problem = ODEProblem(SIR!, u0, tspan, p0)  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Create problem once so we can `remake`.</span>
)
    &#946; ~ truncated(Normal(2, 1); lower=0)
    &#947; ~ truncated(Normal(0.4, 0.5); lower=0)
    &#981;&#8315;&#185; ~ Exponential(1/5)
    &#981; = inv(&#981;&#8315;&#185;)

    problem_new = remake(problem, p=[&#946;, &#947;])  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Replace parameters `p`.</span>
    sol = solve(problem_new, saveat=1)       <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve!</span>

    sol_for_observed = sol[2, 2:num_days + 1]  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Timesteps we have observations for.</span>
    in_bed = Vector{Int}(<span style="color: #97365B;">undef</span>, num_days)
    <span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:length(sol_for_observed)
        <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Add a small constant to `sol_for_observed` to make things more stable.</span>
        in_bed[i] ~ NegativeBinomial2(sol_for_observed[i] + 1e-5, &#981;)
    <span style="color: #3B6EA8;">end</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Some quantities we might be interested in.</span>
    <span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
sir_model (generic function with 2 methods)
</pre>


<p>
Let's break it down
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>&#946; ~ truncated(Normal(2, 1); lower=0)
&#947; ~ truncated(Normal(0.4, 0.5); lower=0)
&#981;&#8315;&#185; ~ Exponential(1/5)
&#981; = inv(&#981;&#8315;&#185;)
</code></pre>
</div>

<p>
defines our prior
</p>

<p>
<code>truncated</code> is just a way of restricting the domain of the distribution you pass it
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>problem_new = remake(problem, p=[&#946;, &#947;])  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Replace parameters `p`.</span>
sol = solve(problem_new, saveat=1)       <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve!</span>
</code></pre>
</div>

<p>
We then remake the problem, now with the parameters <code>[β, γ]</code> sampled above
</p>

<p>
<code>saveat = 1</code> gets us the solution at the timesteps <code>[0, 1, 2, ..., 14]</code>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
Then we extract the timesteps we have observations for
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sol_for_observed = sol[2, 2:num_days + 1]  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Timesteps we have observations for.</span>
</code></pre>
</div>

<p>
and define what's going to be a likelihood (once we add observations)
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>in_bed = Vector{Int}(<span style="color: #97365B;">undef</span>, num_days)
<span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:length(sol_for_observed)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Add a small constant to `sol_for_observed` to make things more stable.</span>
    in_bed[i] ~ NegativeBinomial2(sol_for_observed[i] + 1e-5, &#981;)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<p>
Finally we return some values that might be of interest to
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Some quantities we might be interested in.</span>
<span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
</code></pre>
</div>

<p>
This is useful for a post-sampling diagnostics, debugging, etc.
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Bayesian-inference-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model = sir_model(length(data.in_bed))
</code></pre>
</div>

<pre class="example">
Model(
  args = (:num_days, :tspan, :u0, :p0, :problem)
  defaults = (:tspan, :u0, :p0, :problem)
  context = DynamicPPL.DefaultContext()
)
</pre>


<p>
The model is just another function, so we can call it to check that it works
</p>

<div class="fragment (appear)">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model().infected
</code></pre>
</div>

<pre class="example">
14-element Vector{Float64}:
   4.629880098761509
  20.51149899075346
  76.01682025343723
 170.19683994223317
 188.1484617193551
 130.8534765547809
  74.41578155120635
  38.968883878630315
  19.70373448216648
   9.79913321292256
   4.837363010506036
   2.3788515858966703
   1.167609404493511
   0.5726457769454385
</pre>

<p>
Hey, it does!
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable">
<h3 id="2023-01-29-16-57-28-Is-the-prior-reasonable">Is the prior reasonable?</h3>
<p>
Before we do any inference, we should check if the prior is reasonable
</p>

<p>
From domain knowledge we know that (for influenza at least)
</p>
<ul>
<li class="fragment appear">\(R_0\) is typically between 1 and 2</li>
<li class="fragment appear"><code>recovery_time</code> (\(1 / \gamma\)) is usually ~1 week</li>

</ul>

<div class="fragment (appear)">

<p>
We want to make sure that your prior belief reflects this knowledge while still being flexible enough to accommodate the observations
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">

<p>
To check this we'll just simulate some draws from our prior model, i.e. the model <i>without</i> conditioning on <code>in_bed</code>
</p>

<p>
There are two ways to sample form the prior
</p>

<div class="fragment (appear)">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">1. By just calling the `model`, which returns a `NamedTuple` containing the quantities of interest</span>
print(model())
</code></pre>
</div>

<pre class="example">
(R0 = 1.5744220262579935, recovery_time = 1.0914322040400142, infected = [1.686706278885068, 2.8316832197830895, 4.716863573067216, 7.756274929408289, 12.489841589345032, 19.460362335608362, 28.856011572547263, 39.90424926578871, 50.43351515502132, 57.45932083686618, 58.82922439267481, 54.59403067743465, 46.666918039077295, 37.41622088550463])
</pre>


</div>

<div class="fragment (appear)">

<p>
Or by just calling <code>sample</code> using <code>Prior</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Sample from prior.</span>
chain_prior = sample(model, Prior(), 10_000);
</code></pre>
</div>

<pre class="example">
Sampling:  17%|███████                                  |  ETA: 0:00:01Sampling:  38%|███████████████▋                         |  ETA: 0:00:01Sampling:  58%|███████████████████████▋                 |  ETA: 0:00:00Sampling:  72%|█████████████████████████████▊           |  ETA: 0:00:00Sampling:  87%|███████████████████████████████████▋     |  ETA: 0:00:00Sampling: 100%|█████████████████████████████████████████| Time: 0:00:00
</pre>


</div>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">

<p>
Let's have a look at the prior predictive
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>p = plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300))
plot_trajectories!(p, group(chain_prior, <span style="color: #97365B;">:in_bed</span>); n = 1000)
hline!([N], color=<span style="color: #4F894C;">"red"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/f110b08ba2b09629fd9d3c498a45a8ab21e0915a.png" alt="f110b08ba2b09629fd9d3c498a45a8ab21e0915a.png" />
</p>
</div>

<p class="fragment (appear)">
For certain values we get number of infected <i>larger</i> than the actual population
</p>

<p class="fragment (appear)">
But this is includes the randomness from <code>NegativeBinomial2</code> likelihood
</p>

<p class="fragment (appear)">
Maybe more useful to inspect the (I)nfected state from the ODE solution?
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">

<p>
We can also look at the <code>generated_quantities</code>, i.e. the values from the <code>return</code> statement in our model
</p>

<p>
Our <code>return</code> looked like this
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Some quantities we might be interested in.</span>
<span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
</code></pre>
</div>

<p>
and so <code>generated_quantities</code> (conditioned on <code>chain_prior</code>) gives us
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>quantities_prior = generated_quantities(
    model,
    MCMCChains.get_sections(chain_prior, <span style="color: #97365B;">:parameters</span>)
)
print(quantities_prior[1])
</code></pre>
</div>

<pre class="example">
(R0 = 4.605690136988736, recovery_time = 2.233647692485423, infected = [4.984997209753707, 24.029092981830093, 99.82240918848625, 261.07361336182714, 344.54043982014423, 295.98314301752475, 215.79118631762378, 148.29201252405755, 99.44804435344652, 65.92385902526553, 43.43722911865047, 28.520552363047532, 18.69045660211042, 12.232600393221547])
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">

<p>
We can convert it into a <code>Chains</code> using a utility function of mine
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Convert to `Chains`.</span>
chain_quantities_prior = to_chains(quantities_prior);

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Plot.</span>
p = plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300))
plot_trajectories!(p, group(chain_quantities_prior, <span style="color: #97365B;">:infected</span>); n = 1000)
hline!([N], color=<span style="color: #4F894C;">"red"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/a1b75cd5d378febc7029c1ed63db2831e09ab9ee.png" alt="a1b75cd5d378febc7029c1ed63db2831e09ab9ee.png" />
</p>
</div>

<div class="x-small-text">

<p>
<b>NOTE:</b> <code>to_chains</code> is not part of "official" Turing.jl because the <code>return</code> can contain <i>whatever</i> you want, and so it's not always possible to convert into a <code>Chains</code>
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">

<p>
And the quantiles for the trajectories
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>p = plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300))
plot_trajectory_quantiles!(p, group(chain_quantities_prior, <span style="color: #97365B;">:infected</span>))
hline!(p, [N], color=<span style="color: #4F894C;">"red"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/3f7598c6f0df5f376d9f89161504465787bacf25.png" alt="3f7598c6f0df5f376d9f89161504465787bacf25.png" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Is-the-prior-reasonable-split">


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>DataFrame(quantile(chain_quantities_prior[:, [<span style="color: #97365B;">:R0</span>, <span style="color: #97365B;">:recovery_time</span>], :]))
</code></pre>
</div>

<pre class="example">
2×6 DataFrame
 Row │ parameters     2.5%      25.0%    50.0%    75.0%    97.5%   
     │ Symbol         Float64   Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────────────────────
   1 │ R0             0.487053  2.09801  3.70619  7.31515  62.3576
   2 │ recovery_time  0.706025  1.21271  1.88363  3.46962  29.1143
</pre>


<p>
Compare to our prior knowledge of \(R_0 \in [1, 2]\) and \((1/\gamma) \approx 1\) for influenza
</p>

<p>
Do we really need probability mass on \(R_0 \ge 10\)?
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-s-wrong-with-the-current-prior">
<h3 id="2023-01-29-16-57-28-What-s-wrong-with-the-current-prior"><span class="todo TASK">TASK</span> What's wrong with the current prior?</h3>
<div class="side-by-side">

<div style="margin: auto;">

<p>
The SIR model
</p>

<div>
\begin{equation*}
\begin{split}
  \frac{\mathrm{d} S}{\mathrm{d} t} &= - \beta S \frac{I}{N} \\
  \frac{\mathrm{d} I}{\mathrm{d} t} &= \beta S \frac{I}{N} - \gamma I \\
  \frac{\mathrm{d} R}{\mathrm{d} t} &= \gamma I
\end{split}
\end{equation*}

</div>

</div>

<div>

<p>
And here's the current priors
</p>

<div class="x-small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(
    plot(truncated(Normal(2, 1); lower=0), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#946;"</span>),
    plot(truncated(Normal(0.4, 0.5); lower=0), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#947;"</span>),
    plot(Exponential(1/5), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#981;&#8315;&#185;"</span>),
    layout=(3, 1)
)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/80c76ad5d3151ec0f3e044a075b2a5b88956d14b.png" alt="80c76ad5d3151ec0f3e044a075b2a5b88956d14b.png" />
</p>
</div>

</div>

</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Recovery-time-shouldn-t-be-several-years">
<h3 id="2023-01-29-16-57-28-Recovery-time-shouldn-t-be-several-years"><span class="done SOLUTION">SOLUTION</span> Recovery time shouldn't be several years</h3>
<p>
We mentioned that <code>recovery_time</code>, which is expressed as \(1 / \gamma\), is ~1 week
</p>

<p>
We're clearly putting high probability on regions near 0, i.e. <i>long</i> recovery times
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(truncated(Normal(0.4, 0.5); lower=0), label=<span style="color: #97365B;">nothing</span>, title=<span style="color: #4F894C;">"&#947;"</span>, size=(500, 300))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/ed3058dc552f72dbe5151feb938d103b75251f63.png" alt="ed3058dc552f72dbe5151feb938d103b75251f63.png" />
</p>
</div>

<p>
<span class="underline">Should probably be putting less probability mass near 0</span>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-color-red-gamma-should-not-be-larger-than-1">
<h3 id="2023-01-29-16-57-28-color-red-gamma-should-not-be-larger-than-1"><span class="done SOLUTION">SOLUTION</span> \({\color{red} \gamma}\) should not be larger than 1</h3>
<div>
\begin{equation*}
\begin{split}
  \frac{\mathrm{d} S}{\mathrm{d} t} &= - \beta S \frac{I}{N} \\
  \frac{\mathrm{d} I}{\mathrm{d} t} &= \beta S \frac{I}{N} - {\color{red} \gamma I} \\
  \frac{\mathrm{d} R}{\mathrm{d} t} &= {\color{red} \gamma I}
\end{split}
\end{equation*}

</div>

<p>
If \({\color{red} \gamma} > 1\) ⟹ (R)ecovered increase by <i>more</i> than the (I)nfected
</p>

<p>
⟹ <span class="underline">healthy people are recovering</span>
</p>

<div class="small-text" style="color: red;">

<p>
<span class="timestamp-wrapper"><span class="timestamp">[2023-01-27 Fri] </span></span> This was, <span class="underline">rightly so</span>, contested when I presented this, as the conservation is preserved by the system independent of the value of \(\gamma\) (as long as it's positive). There is an argument to be made about having a recovery time of &lt;1 day, i.e. \(\gamma > 1\), being unreasonable, but <b>the reasoning above is incorrect!</b>
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-color-red-gamma-should-not-be-larger-than-1-split">

<div style="color: red;">

<p>
Just to convince ourselves that it is indeed not a problem with \(\gamma > 1\), we can just run the model with a large \(\gamma\) and look at the <code>in_bed</code> under this prior.
</p>

</div>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_gamma = model | (&#947; = 1.5, )
chain_gamma = sample(model_gamma, Prior(), 10_000, progress=<span style="color: #97365B;">false</span>)

p1 = plot_trajectories!(plot(legend=<span style="color: #97365B;">false</span>), group(chain_gamma, <span style="color: #97365B;">:in_bed</span>))
hline!(p1, [N], color=<span style="color: #4F894C;">"red"</span>)

p2 = plot_trajectory_quantiles!(plot(legend=<span style="color: #97365B;">false</span>), group(chain_gamma, <span style="color: #97365B;">:in_bed</span>))
hline!(p2, [N], color=<span style="color: #4F894C;">"red"</span>)

plot(p1, p2, layout=(2,1), size=(600, 400))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/856d2889f03822cd9dffef93e27f71c0c4c4c645.png" alt="856d2889f03822cd9dffef93e27f71c0c4c4c645.png" />
</p>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-color-red-gamma-should-not-be-larger-than-1-split">

<p>
Maybe something like
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(Beta(2, 5), label=<span style="color: #4F894C;">"new"</span>, size=(500, 300))
plot!(truncated(Normal(0.4, 0.5); lower=0), label=<span style="color: #4F894C;">"old"</span>, color=<span style="color: #4F894C;">"red"</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/bc9d6892a46d578ee1b80fb8d98ab74a44e0e9ce.png" alt="bc9d6892a46d578ee1b80fb8d98ab74a44e0e9ce.png" />
</p>
</div>

<ul>
<li class="on"><code>[X]</code> Bounded at 1 to exlcude recovery time of less than 1 day</li>
<li class="on"><code>[X]</code> Allows smaller values (i.e. longer recovery time) but rapidly decreases near zero</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N">
<h3 id="2023-01-29-16-57-28-What-if-color-red-beta-N"><span class="done SOLUTION">SOLUTION</span> What if \({\color{red} \beta} > N\)?</h3>
<p>
Then for \(t = 0\) we have
</p>
<div>
\begin{equation*}
\frac{\mathrm{d} S}{\mathrm{d} t} \bigg|_{t = 0} = - {\color{red} \beta} S \frac{I}{N} > - N (N - 1) \frac{1}{N} = - (N - 1)
\end{equation*}

</div>

<p>
i.e. we <i>immediately</i> infect everyone on the very first time-step
</p>

<p>
Also doesn't seem very realistic
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
<i>But</i> under our current prior does this matter?
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">&#8473;(&#946; &gt; N) = 1 - &#8473;(&#946; &#8804; N)</span>
1 - cdf(truncated(Normal(2, 1); lower=0), N)
</code></pre>
</div>

<pre class="example">
0.0
</pre>


<p>
Better yet
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>quantile(truncated(Normal(2, 1); lower=0), 0.95)
</code></pre>
</div>

<pre class="example">
3.6559843567138275
</pre>


<p>
i.e. 95% of the probability mass falls below ~3.65
</p>

<p>
⟹ <span class="underline">Current prior for \(\beta\) seems fine (✓)</span>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
Before we change the prior, let's also make it a bit easier to change the prior using <code>@submodel</code>
</p>

<div class="fragment (appear)">

<p>
<code>@submodel</code> allows you call models within models, e.g.
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> A()
    x_hidden_from_B ~ Normal()
    x = x_hidden_from_B + 100
    <span style="color: #3B6EA8;">return</span> x
<span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> B()
    <span style="color: #3B6EA8; font-weight: bold;">@submodel</span> x = A()
    y ~ Normal(x, 1)

    <span style="color: #3B6EA8;">return</span> (; x, y)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
B (generic function with 2 methods)
</pre>


</div>

<div class="fragment (appear)">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">So if we call `B` we only see `x` and `y`</span>
println(B()())
</code></pre>
</div>

<pre class="example">
(x = 101.54969461293537, y = 102.48444715535948)
</pre>


</div>

<div class="fragment (appear)">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">While if we sample from `B` we get the latent variables</span>
println(rand(B()))
</code></pre>
</div>

<pre class="example">
(x_hidden_from_B = 0.18899969500711336, y = 99.3704062023967)
</pre>


</div>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
To avoid clashes of variable-names, we can specify a <code>prefix</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> A() = (x ~ Normal(); <span style="color: #3B6EA8;">return</span> x + 100)

<span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> B()
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Given it a prefix to use for the variables in `A`.</span>
    <span style="color: #3B6EA8; font-weight: bold;">@submodel</span> prefix=<span style="color: #97365B;">:inner</span> x_inner = A()
    x ~ Normal(x_inner, 1)

    <span style="color: #3B6EA8;">return</span> (; x_inner, x)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
B (generic function with 2 methods)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>print(rand(B()))
</code></pre>
</div>

<pre class="example">
(var"inner.x" = 0.45580772395367214, x = 100.5643900955249)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
<code>@submodel</code> is useful as it allows you to:
</p>
<ol>
<li>Easy to swap out certain parts of your model.</li>
<li>Can re-use models across projects and packages.</li>

</ol>

<p>
When working on larger projects, this really shines
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
Equipped with <code>@submodel</code> we can replace
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>&#946; ~ truncated(Normal(2, 1); lower=0)
&#947; ~ truncated(Normal(0.4, 0.5); lower=0)
</code></pre>
</div>

<p>
with
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@submodel</span> p = prior(problem_wrapper)
</code></pre>
</div>

<div class="fragment (appear)">

<p>
where <code>prior</code> can be something like
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> prior_original(problem_wrapper::<span style="color: #9A7500;">SIRProblem</span>)
    &#946; ~ truncated(Normal(2, 1); lower=0)
    &#947; ~ truncated(Normal(0.4, 0.5); lower=0)

    <span style="color: #3B6EA8;">return</span> [&#946;, &#947;]
<span style="color: #3B6EA8;">end</span>

<span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> prior_improved(problem_wrapper::<span style="color: #9A7500;">SIRProblem</span>)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Should probably also lower mean for `&#946;` since</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">more probability mass on small `&#947;` &#10233; `R0 =  &#946; / &#947;` grows.</span>
    &#946; ~ truncated(Normal(1, 1); lower=0)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> New prior for `&#947;`.</span>
    &#947; ~ Beta(2, 5)

    <span style="color: #3B6EA8;">return</span> [&#946;, &#947;]
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
prior_improved (generic function with 2 methods)
</pre>


</div>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> epidemic_model(
    problem_wrapper::<span style="color: #9A7500;">AbstractEpidemicProblem</span>,
    prior  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> now we just pass the prior as an argument</span>
)
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> And use `@submodel` to embed the `prior` in our model.</span>
    <span style="color: #3B6EA8; font-weight: bold;">@submodel</span> p = prior(problem_wrapper)

    &#981;&#8315;&#185; ~ Exponential(1/5)
    &#981; = inv(&#981;&#8315;&#185;)

    problem_new = remake(problem_wrapper.problem, p=p)  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Replace parameters `p`.</span>
    sol = solve(problem_new, saveat=1)                  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve!</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Extract the `infected`.</span>
    sol_for_observed = infected(problem_wrapper, sol)[2:<span style="color: #3B6EA8;">end</span>]

    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> `arraydist` is faster for larger dimensional problems,</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">and it does not require explicit allocation of the vector.</span>
    in_bed ~ arraydist(NegativeBinomial2.(sol_for_observed .+ 1e-5, &#981;))

    &#946;, &#947; = p[1:2]
    <span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
epidemic_model (generic function with 3 methods)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<div class="x-small-text">

<p>
Another neat trick is to return early if integration fail
</p>

</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> epidemic_model(
    problem_wrapper::<span style="color: #9A7500;">AbstractEpidemicProblem</span>,
    prior  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">now we just pass the prior as an argument</span>
)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">And use `@submodel` to embed the `prior` in our model.</span>
    <span style="color: #3B6EA8; font-weight: bold;">@submodel</span> p = prior(problem_wrapper)

    &#981;&#8315;&#185; ~ Exponential(1/5)
    &#981; = inv(&#981;&#8315;&#185;)

    problem_new = remake(problem_wrapper.problem, p=p)  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Replace parameters `p`.</span>
    sol = solve(problem_new, saveat=1)                  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve!</span>

    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Return early if integration failed.</span>
    <span style="color: #3B6EA8;">if</span> !issuccess(sol)
        Turing.<span style="color: #3B6EA8; font-weight: bold;">@addlogprob!</span> -<span style="color: #97365B;">Inf</span>  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Causes automatic rejection.</span>
        <span style="color: #3B6EA8;">return</span> <span style="color: #97365B;">nothing</span>
    <span style="color: #3B6EA8;">end</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Extract the `infected`.</span>
    sol_for_observed = infected(problem_wrapper, sol)[2:<span style="color: #3B6EA8;">end</span>]

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">`arraydist` is faster for larger dimensional problems,</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">and it does not require explicit allocation of the vector.</span>
    in_bed ~ arraydist(NegativeBinomial2.(sol_for_observed .+ 1e-5, &#981;))

    &#946;, &#947; = p[1:2]
    <span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
epidemic_model (generic function with 3 methods)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
Equipped with this we can now easily construct <i>two</i> models using different priors
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>sir = SIRProblem(N);
model_original = epidemic_model(sir, prior_original);
model_improved = epidemic_model(sir, prior_improved);
</code></pre>
</div>

<p>
but using the same underlying <code>epidemic_model</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain_prior_original = sample(model_original, Prior(), 10_000; progress=<span style="color: #97365B;">false</span>);
chain_prior_improved = sample(model_improved, Prior(), 10_000; progress=<span style="color: #97365B;">false</span>);
</code></pre>
</div>

<p>
Let's compare the resulting priors over some of the quantities of interest
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
Let's compare the <code>generated_quantities</code>, e.g. \(R_0\)
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain_quantities_original = to_chains(
    generated_quantities(
        model_original,
        MCMCChains.get_sections(chain_prior_original, <span style="color: #97365B;">:parameters</span>)
    );
);

chain_quantities_improved = to_chains(
    generated_quantities(
        model_improved,
        MCMCChains.get_sections(chain_prior_improved, <span style="color: #97365B;">:parameters</span>)
    );
);
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>p = plot(; legend=<span style="color: #97365B;">false</span>, size=(500, 200))
plot_trajectories!(p, group(chain_quantities_original, <span style="color: #97365B;">:infected</span>); n = 100, trajectory_color=<span style="color: #4F894C;">"red"</span>)
plot_trajectories!(p, group(chain_quantities_improved, <span style="color: #97365B;">:infected</span>); n = 100, trajectory_color=<span style="color: #4F894C;">"blue"</span>)
hline!([N], color=<span style="color: #4F894C;">"red"</span>, linestyle=<span style="color: #97365B;">:dash</span>)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/2e1579a71c4072534cabe41a233cd283543874e6.png" alt="2e1579a71c4072534cabe41a233cd283543874e6.png" />
</p>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plt1 = plot(legend=<span style="color: #97365B;">false</span>)
plot_trajectory_quantiles!(plt1, group(chain_quantities_original, <span style="color: #97365B;">:infected</span>))
hline!(plt1, [N], color=<span style="color: #4F894C;">"red"</span>, linestyle=<span style="color: #97365B;">:dash</span>)

plt2 = plot(legend=<span style="color: #97365B;">false</span>)
plot_trajectory_quantiles!(plt2, group(chain_quantities_improved, <span style="color: #97365B;">:infected</span>))
hline!(plt2, [N], color=<span style="color: #4F894C;">"red"</span>, linestyle=<span style="color: #97365B;">:dash</span>)

plot(plt1, plt2, layout=(2, 1))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/cffea7a80541e6f61fd182de85cb18bc8520b0b4.png" alt="cffea7a80541e6f61fd182de85cb18bc8520b0b4.png" />
</p>
</div>

</div>

<p>
This makes sense: if half of the population is immediately infected ⟹ number of infected tapers wrt. time as they recover
</p>

</section>
<section id="slide-2023-01-29-16-57-28-What-if-color-red-beta-N-split">

<p>
For <code>model_improved</code> we then have
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>DataFrame(quantile(chain_quantities_improved[:, [<span style="color: #97365B;">:R0</span>, <span style="color: #97365B;">:recovery_time</span>], :]))
</code></pre>
</div>

<pre class="example">
2×6 DataFrame
 Row │ parameters     2.5%      25.0%    50.0%    75.0%    97.5%   
     │ Symbol         Float64   Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────────────────────
   1 │ R0             0.295478  2.30191  4.52993  8.41333  35.9603
   2 │ recovery_time  1.55995   2.55853  3.81049  6.31316  23.6136
</pre>


<p>
Compare to <code>model_original</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>DataFrame(quantile(chain_quantities_original[:, [<span style="color: #97365B;">:R0</span>, <span style="color: #97365B;">:recovery_time</span>], :]))
</code></pre>
</div>

<pre class="example">
2×6 DataFrame
 Row │ parameters     2.5%      25.0%    50.0%    75.0%    97.5%   
     │ Symbol         Float64   Float64  Float64  Float64  Float64 
─────┼─────────────────────────────────────────────────────────────
   1 │ R0             0.495283  2.10977  3.7219   7.30474  59.9345
   2 │ recovery_time  0.693234  1.20832  1.88465  3.48181  29.4579
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Make-epidemic-model-work-for-SEIRProblem">
<h3 id="2023-01-29-16-57-28-Make-epidemic-model-work-for-SEIRProblem"><span class="todo TASK">TASK</span> Make <code>epidemic_model</code> work for <code>SEIRProblem</code></h3>
<ol>
<li class="off"><code>[&#xa0;]</code> Implement a prior which also includes \(\sigma\) and execute
<code>epidemic_model</code> with it</li>
<li class="off"><code>[&#xa0;]</code> Can we make a better prior for \(\sigma\)? Do we even need one?</li>

</ol>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> prior_original(problem_wrapper::<span style="color: #9A7500;">SEIRProblem</span>)
    <span style="color: #8b94a5;"># </span><span style="color: #9A7500; font-weight: bold;">TODO:</span><span style="color: #8b94a5;"> Implement</span>
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-">
<h3 id="2023-01-29-16-57-28-">SOLUTION</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> prior_original(problem_wrapper::<span style="color: #9A7500;">SEIRProblem</span>)
    &#946; ~ truncated(Normal(2, 1); lower=0)
    &#947; ~ truncated(Normal(0.4, 0.5); lower=0)
    &#963; ~ truncated(Normal(0.8, 0.5); lower=0)

    <span style="color: #3B6EA8;">return</span> [&#946;, &#947;, &#963;]
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
prior_original (generic function with 4 methods)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_seir = epidemic_model(SEIRProblem(N), prior_original)
print(model_seir())
</code></pre>
</div>

<pre class="example">
(R0 = 1.249905922185047, recovery_time = 1.1275375476185503, infected = [0.41458760197101757, 0.175982147386383, 0.07874256170480576, 0.03911764946193381, 0.02298161307777028, 0.01641950959805482, 0.013759122196211936, 0.012689081710378131, 0.012267493170560804, 0.012110652999146742, 0.012061533724674748, 0.012055660061838289, 0.01206858103422115, 0.012088341860835633])
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Consult-with-domain-experts">
<h3 id="2023-01-29-16-57-28-Consult-with-domain-experts"><span class="todo WARNING">WARNING</span> Consult with domain experts</h3>
<p>
This guy should <span class="underline">not</span> be the one setting your priors!
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-18_14-49-24_471337_3317365246956_1262712540_o.jpg" alt="2023-01-18_14-49-24_471337_3317365246956_1262712540_o.jpg" height="400px" />
</p>
</div>

<p>
Get an actual scientist to do that&#x2026;
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Condition">
<h3 id="2023-01-29-16-57-28-Condition">Condition</h3>
<p>
Now let's actually involve the data
</p>

<div class="fragment (appear)">

<p>
We can condition a <code>Model</code> as so
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Condition on the observations.</span>
model = epidemic_model(SIRProblem(N), prior_improved)
model_conditioned = model | (in_bed = data.in_bed,)
</code></pre>
</div>

<pre class="example">
Model(
  args = (:problem_wrapper, :prior)
  defaults = ()
  context = ConditionContext((in_bed = [3, 8, 26, 76, 225, 298, 258, 233, 189, 128, 68, 29, 14, 4],), DynamicPPL.DefaultContext())
)
</pre>


</div>

<div class="fragment (appear)">

<p>
You know what time it is: <i>inference time</i>!
</p>

</div>


</section>
<section id="slide-2023-01-29-16-57-28-Metropolis-Hastings--MH">
<h3 id="2023-01-29-16-57-28-Metropolis-Hastings--MH">Metropolis-Hastings (MH)</h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain_mh = sample(model_conditioned, MH(), MCMCThreads(), 10_000, 4; discard_initial=5_000);
</code></pre>
</div>

<p>
Rhat is <i>okay-ish</i> but not great, and ESS is pretty low innit?
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Metropolis-Hastings--MH-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(chain_mh; size=(800, 500))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/7763ba1e7b6bb223fde4d453cab14cbcf723b75a.png" alt="7763ba1e7b6bb223fde4d453cab14cbcf723b75a.png" />
</p>
</div>

<p>
Eeehh doesn't look the greatest
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Metropolis-Hastings--MH-split">

<p>
Difficult to trust these results, but let's check if it at least did <i>something</i> useful
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">We're using the unconditioned model!</span>
predictions_mh = predict(model, chain_mh)
</code></pre>
</div>

<pre class="example">
Chains MCMC chain (10000×14×4 Array{Float64, 3}):

Iterations        = 1:1:10000
Number of chains  = 4
Samples per chain = 10000
parameters        = in_bed[1], in_bed[2], in_bed[3], in_bed[4], in_bed[5], in_bed[6], in_bed[7], in_bed[8], in_bed[9], in_bed[10], in_bed[11], in_bed[12], in_bed[13], in_bed[14]
internals         = 

Summary Statistics
  parameters       mean       std   naive_se      mcse          ess      rhat 
      Symbol    Float64   Float64    Float64   Float64      Float64   Float64 

   in_bed[1]     3.3239    2.1843     0.0109    0.0157   30552.3306    1.0007
   in_bed[2]    10.9294    5.2800     0.0264    0.0765    3416.2516    1.0035
   in_bed[3]    34.2420   15.1777     0.0759    0.3451    1224.2460    1.0094
   in_bed[4]    93.9719   40.8019     0.2040    1.0230     986.9341    1.0117
   in_bed[5]   189.9567   76.0954     0.3805    1.6855    1228.9914    1.0092
   in_bed[6]   251.4305   93.8553     0.4693    1.3148    3319.4564    1.0035
   in_bed[7]   238.4202   87.8089     0.4390    1.0119    5807.9491    1.0019
   in_bed[8]   187.8321   70.0577     0.3503    1.0287    3162.2209    1.0030
   in_bed[9]   133.3270   50.5663     0.2528    0.8771    2085.0535    1.0031
  in_bed[10]    90.4691   35.6730     0.1784    0.6878    1522.7552    1.0053
  in_bed[11]    60.0969   24.7118     0.1236    0.5338    1282.4864    1.0065
  in_bed[12]    39.1181   16.8669     0.0843    0.3941    1036.7038    1.0085
  in_bed[13]    25.4850   11.6236     0.0581    0.2900     899.2603    1.0112
  in_bed[14]    16.4625    8.0545     0.0403    0.2026     874.3031    1.0101

Quantiles
  parameters       2.5%      25.0%      50.0%      75.0%      97.5% 
      Symbol    Float64    Float64    Float64    Float64    Float64 

   in_bed[1]     0.0000     2.0000     3.0000     5.0000     8.0000
   in_bed[2]     3.0000     7.0000    10.0000    14.0000    23.0000
   in_bed[3]    12.0000    24.0000    32.0000    42.0000    70.0000
   in_bed[4]    35.0000    67.0000    87.0000   113.0000   192.0000
   in_bed[5]    76.0000   138.0000   179.0000   228.0000   373.0000
   in_bed[6]   102.0000   188.0000   240.0000   301.0000   469.0000
   in_bed[7]    97.0000   178.0000   228.0000   287.0000   439.0000
   in_bed[8]    75.0000   140.0000   180.0000   226.0000   350.0000
   in_bed[9]    52.0000    98.0000   128.0000   161.0000   250.0000
  in_bed[10]    34.0000    66.0000    86.0000   110.0000   172.0000
  in_bed[11]    21.0000    43.0000    57.0000    73.0000   117.0000
  in_bed[12]    13.0000    28.0000    37.0000    48.0000    78.0000
  in_bed[13]     8.0000    17.0000    24.0000    32.0000    53.0000
  in_bed[14]     4.0000    11.0000    15.0000    21.0000    35.0000
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Metropolis-Hastings--MH-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot_trajectories!(plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300)), predictions_mh; data=data)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/53d5bcefafe0e9c29e4ee0f560bc2648d8b43118.png" alt="53d5bcefafe0e9c29e4ee0f560bc2648d8b43118.png" />
</p>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot_trajectory_quantiles!(plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300)), predictions_mh; data=data)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/0d84524cc352ba3471bf66156dda0a8cfd1e66b9.png" alt="0d84524cc352ba3471bf66156dda0a8cfd1e66b9.png" />
</p>
</div>

<p>
Okay, it's not <i>completely</i> useless, but my trust-issues are still present.
</p>

<p>
Metropolis-Hastings have disappointed me one too many times before.
</p>

</section>
<section id="slide-2023-01-29-16-57-28-So-instead-let-s-go-NUTS">
<h3 id="2023-01-29-16-57-28-So-instead-let-s-go-NUTS">So instead, let's go <code>NUTS</code></h3>
<p>
That's right, we're reaching to the <b>No U-Turn sampler (NUTS)</b>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-" data-background-iframe="file:///home/tor/Projects/public/mcmc-demo/app.html?closeControls=true&amp;algorithm=HamiltonianMH&amp;target=standard&amp;seed=1&amp;autoplay=true&amp;histBins=100" data-background-interactive>
<div style="">
<h4 id="2023-01-29-16-57-28-"></h4>
<p class="fragment (appear)">
<a href="https://chi-feng.github.io/mcmc-demo/app.html" class="fragment (appear)">https://chi-feng.github.io/mcmc-demo/app.html</a>
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-">
<h3 id="2023-01-29-16-57-28-"></h3>
<blockquote >
<p>
Wooaah there! <code>NUTS</code> requires gradient information!
</p>

<p>
How are you going to get that through that <code>solve</code>?
</p>
</blockquote>

<p>
Good question, voice in my head
</p>

<p class="fragment (appear)">
I'm obviously not going to it myself
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Automatic-differentiation--AD--in-Julia">
<h3 id="2023-01-29-16-57-28-Automatic-differentiation--AD--in-Julia">Automatic differentiation (AD) in Julia</h3>
<ul>
<li><a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>: forward-mode AD <i>(default in Turing.jl)</i></li>
<li><a href="https://github.com/JuliaDiff/ReverseDiff.jl">ReverseDiff.jl</a>: tape-based reverse-mode AD</li>
<li><a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a>: source-to-source reverse-mode AD</li>
<li>And more&#x2026;</li>

</ul>

<div class="fragment (appear)">

<p>
Up-and-coming
</p>

<ul>
<li><a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme.jl</a>: Julia bindings for <a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme</a> which ADs LLVM (low-level)</li>
<li><a href="https://github.com/JuliaDiff/Diffractor.jl">Diffractor.jl</a>: experimental mixed-mode AD meant to replace Zygote.jl</li>

</ul>

</div>

<div class="fragment (appear)">

<p>
Of importance
</p>
<ul>
<li><a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a>: light-weight package for defining rules, compatible with many of the above</li>

</ul>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Automatic-differentiation--AD--in-Julia-split">

<p>
<b>Important</b>
</p>

<blockquote >
<p>
When you write code, you don't have to make a choice which one you
want to use!
</p>
</blockquote>

<p>
All the (stable) ones, will (mostly) work
</p>

<p>
<i>But</i> how you write code will affect performance characteristics
</p>

<p>
Takes a bit of know-how + a bit of digging to go properly "vroom!"
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Differentiating-through-solve">
<h3 id="2023-01-29-16-57-28-Differentiating-through-solve">Differentiating through <code>solve</code></h3>
<p>
With that being said, differentiating through numerical <code>solve</code> is not necessarily trivial to do efficiently
</p>

<p>
There are numerous ways of approaching this problem
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-22_12-30-07_Screenshot_20230122_122936.png" alt="2023-01-22_12-30-07_Screenshot_20230122_122936.png" width="400px" />
</p>
</div>

<p>
<a href="https://arxiv.org/abs/1812.01892">https://arxiv.org/abs/1812.01892</a> is <i>great</i> resource
</p>

<div class="fragment (appear)">

<p>
But this is why we have <a href="https://github.com/SciML/SciMLSensitivity.jl"><code>SciMLSensitivity.jl</code></a>
</p>

<p>
<a href="https://docs.sciml.ai/SciMLSensitivity/stable/manual/differential_equation_sensitivities/#Choosing-a-Sensitivity-Algorithm">SciMLSensitivity.jl docs</a> also provides a great overview of different approaches
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Differentiating-through-solve-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> SciMLSensitivity
</code></pre>
</div>

<p>
It offers
</p>

<ol>
<li><i>Discrete sensitivity analysis</i> or the <i>"Direct" method</i>: just use
<code>ForwardDiff.Dual</code> in the <code>solve</code>.</li>
<li><i>Continuous local sensitivity analysis (CSA)</i>: extends the original
system such that the <code>solve</code> gives you both the solution and the the
gradient simultaenously.</li>
<li><i>Adjoint methods</i>: construct a backwards system whose solution gives
us the gradient.</li>

</ol>

<p>
Just do <code>solve(problem, solver, sensealg = ...)</code>
</p>

</section>
<section id="slide-back-to-being-nuts">
<h3 id="back-to-being-nuts">Back to being <code>NUTS</code></h3>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain = sample(model_conditioned, NUTS(0.8), MCMCThreads(), 1000, 4);
</code></pre>
</div>

<pre class="example">
┌ Info: Found initial step size
└   ϵ = 0.8
┌ Info: Found initial step size
└   ϵ = 0.4
┌ Info: Found initial step size
└   ϵ = 0.025
┌ Info: Found initial step size
└   ϵ = 0.05
┌ Warning: The current proposal will be rejected due to numerical error(s).
│   isfinite.((θ, r, ℓπ, ℓκ)) = (true, false, false, false)
└ @ AdvancedHMC ~/.julia/packages/AdvancedHMC/4fByY/src/hamiltonian.jl:49
</pre>

</section>
<section id="slide-back-to-being-nuts-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain
</code></pre>
</div>

<pre class="example">
Chains MCMC chain (1000×15×4 Array{Float64, 3}):

Iterations        = 501:1:1500
Number of chains  = 4
Samples per chain = 1000
Wall duration     = 8.48 seconds
Compute duration  = 33.22 seconds
parameters        = β, γ, ϕ⁻¹
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
  parameters      mean       std   naive_se      mcse         ess      rhat    ⋯
      Symbol   Float64   Float64    Float64   Float64     Float64   Float64    ⋯

           β    1.7305    0.0532     0.0008    0.0012   2305.3519    1.0006    ⋯
           γ    0.5305    0.0430     0.0007    0.0009   2432.0514    0.9998    ⋯
         ϕ⁻¹    0.1349    0.0727     0.0011    0.0015   2211.5812    0.9994    ⋯
                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5% 
      Symbol   Float64   Float64   Float64   Float64   Float64 

           β    1.6279    1.6970    1.7281    1.7618    1.8401
           γ    0.4464    0.5024    0.5294    0.5580    0.6172
         ϕ⁻¹    0.0394    0.0843    0.1180    0.1699    0.3165
</pre>

<p>
Muuuch better! Both ESS and Rhat is looking good
</p>

</section>
<section id="slide-back-to-being-nuts-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot(chain; size=(800, 500))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/ba6a57881c744560992e6aeb0ff47cfb9aaf9238.png" alt="ba6a57881c744560992e6aeb0ff47cfb9aaf9238.png" />
</p>
</div>

</section>
<section id="slide-back-to-being-nuts-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Predict using the results from NUTS.</span>
predictions = predict(model, chain)
</code></pre>
</div>

<pre class="example">
Chains MCMC chain (1000×14×4 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 4
Samples per chain = 1000
parameters        = in_bed[1], in_bed[2], in_bed[3], in_bed[4], in_bed[5], in_bed[6], in_bed[7], in_bed[8], in_bed[9], in_bed[10], in_bed[11], in_bed[12], in_bed[13], in_bed[14]
internals         = 

Summary Statistics
  parameters       mean       std   naive_se      mcse         ess      rhat 
      Symbol    Float64   Float64    Float64   Float64     Float64   Float64 

   in_bed[1]     3.2840    2.1793     0.0345    0.0327   4055.3023    0.9998
   in_bed[2]    10.7950    5.4560     0.0863    0.0749   3714.2037    1.0005
   in_bed[3]    34.0883   15.7327     0.2488    0.2596   3642.2139    1.0001
   in_bed[4]    93.0002   41.3318     0.6535    0.7048   3577.5458    1.0012
   in_bed[5]   187.5652   79.0050     1.2492    1.2543   3478.9204    1.0010
   in_bed[6]   248.9330   97.2779     1.5381    1.6339   4056.1039    1.0008
   in_bed[7]   234.6240   89.1151     1.4090    1.2074   4022.8396    0.9996
   in_bed[8]   185.4033   71.8807     1.1365    1.0479   3860.3337    0.9997
   in_bed[9]   130.9750   50.4204     0.7972    0.8315   3694.8750    0.9999
  in_bed[10]    88.2115   35.8989     0.5676    0.6532   3401.2244    0.9999
  in_bed[11]    59.4943   25.4118     0.4018    0.4155   3460.7875    0.9997
  in_bed[12]    38.6793   16.7184     0.2643    0.2929   3697.7714    1.0005
  in_bed[13]    24.8678   11.4870     0.1816    0.2081   3578.3080    1.0001
  in_bed[14]    15.9450    8.2237     0.1300    0.1376   3389.6307    0.9996

Quantiles
  parameters      2.5%      25.0%      50.0%      75.0%      97.5% 
      Symbol   Float64    Float64    Float64    Float64    Float64 

   in_bed[1]    0.0000     2.0000     3.0000     5.0000     8.0000
   in_bed[2]    2.9750     7.0000    10.0000    14.0000    24.0000
   in_bed[3]   11.0000    24.0000    32.0000    42.0000    73.0000
   in_bed[4]   33.0000    65.0000    87.0000   113.0000   190.0000
   in_bed[5]   69.0000   134.0000   177.0000   226.0000   376.0000
   in_bed[6]   95.0000   184.0000   237.0000   299.0000   473.0250
   in_bed[7]   88.0000   175.0000   224.0000   283.0000   440.0250
   in_bed[8]   70.0000   137.0000   176.0000   225.0000   351.0000
   in_bed[9]   49.0000    96.0000   126.0000   159.0000   245.0000
  in_bed[10]   31.9750    64.0000    84.0000   107.0000   170.0000
  in_bed[11]   19.0000    42.0000    57.0000    73.0000   118.0250
  in_bed[12]   13.0000    27.0000    36.0000    48.0000    77.0000
  in_bed[13]    7.0000    17.0000    23.0000    31.0000    51.0000
  in_bed[14]    4.0000    10.0000    15.0000    20.0000    36.0000
</pre>

</section>
<section id="slide-back-to-being-nuts-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot_trajectories!(plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300)), predictions; n = 1000, data=data)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/870b8fafd890396444043fd96c7d303fb7722627.png" alt="870b8fafd890396444043fd96c7d303fb7722627.png" />
</p>
</div>

</section>
<section id="slide-back-to-being-nuts-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>plot_trajectory_quantiles!(plot(legend=<span style="color: #97365B;">false</span>, size=(600, 300)), predictions; data=data)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/145ba1245ad3196f9bb3001254df5b3cf451e778.png" alt="145ba1245ad3196f9bb3001254df5b3cf451e778.png" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Simulation-based-calibration--SBC--https-arxiv-dot-org-abs-1804-dot-06788-Talts-et-dot-al-dot--2018">
<h3 id="2023-01-29-16-57-28-Simulation-based-calibration--SBC--https-arxiv-dot-org-abs-1804-dot-06788-Talts-et-dot-al-dot--2018">Simulation-based calibration (SBC) <a href="https://arxiv.org/abs/1804.06788">Talts et. al. (2018)</a></h3>
<ol>
<li>Sample from prior \(\theta_1, \dots, \theta_n \sim p(\theta)\).</li>
<li>Sample datasets \(\mathcal{D}_i \sim p(\cdot \mid \theta_i)\) for \(i = 1, \dots, n\).</li>
<li>Obtain (approximate) \(p(\theta \mid \mathcal{D}_i)\) for \(i = 1, \dots, n\).</li>

</ol>

<p>
For large enough (n), the "combination" of the posteriors should recover the prior!
</p>

<p>
"Combination" here usually means computing some statistic and comparing against what it should be
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-22_12-09-24_Screenshot_20230122_120848.png" alt="2023-01-22_12-09-24_Screenshot_20230122_120848.png" width="800px" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Simulation-based-calibration--SBC--https-arxiv-dot-org-abs-1804-dot-06788-Talts-et-dot-al-dot--2018-split">

<p>
That's very expensive → in practice we just do this once or twice
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Sample from the conditioned model so we don't get the `in_bed` variables too</span>
<span style="color: #3B6EA8;">using</span> Random  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Just making usre the numbers of somewhat interesting</span>
rng = MersenneTwister(43);
test_values = rand(rng, NamedTuple, model_conditioned)
</code></pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">β</td>
<td class="org-left">=</td>
<td class="org-right">1.2254566808077714</td>
<td class="org-left">γ</td>
<td class="org-left">=</td>
<td class="org-right">0.27594266205681933</td>
<td class="org-left">ϕ⁻¹</td>
<td class="org-left">=</td>
<td class="org-right">0.13984179162984164</td>
</tr>
</tbody>
</table>

<p>
Now we condition on those values and run once to generate data
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_test = model | test_values
</code></pre>
</div>

<pre class="example">
Model(
  args = (:problem_wrapper, :prior)
  defaults = ()
  context = ConditionContext((β = 1.2254566808077714, γ = 0.27594266205681933, ϕ⁻¹ = 0.13984179162984164), DynamicPPL.DefaultContext())
)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>in_best_test = rand(rng, model_test).in_bed;
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Simulation-based-calibration--SBC--https-arxiv-dot-org-abs-1804-dot-06788-Talts-et-dot-al-dot--2018-split">

<p>
Next, inference!
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_test_conditioned = model | (in_bed = in_best_test,)
</code></pre>
</div>

<pre class="example">
Model(
  args = (:problem_wrapper, :prior)
  defaults = ()
  context = ConditionContext((in_bed = [1, 9, 11, 45, 159, 136, 270, 123, 463, 376, 231, 148, 99, 162],), DynamicPPL.DefaultContext())
)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Let's just do a single chain here.</span>
chain_test = sample(model_test_conditioned, NUTS(0.8), 1000);
</code></pre>
</div>

<pre class="example">
┌ Info: Found initial step size
└   ϵ = 0.0125
Sampling:   4%|█▊                                       |  ETA: 0:00:05Sampling:  12%|████▊                                    |  ETA: 0:00:02Sampling:  25%|██████████▏                              |  ETA: 0:00:01Sampling:  39%|███████████████▉                         |  ETA: 0:00:01Sampling:  52%|█████████████████████▍                   |  ETA: 0:00:01Sampling:  66%|███████████████████████████              |  ETA: 0:00:00Sampling:  80%|████████████████████████████████▊        |  ETA: 0:00:00Sampling:  93%|██████████████████████████████████████   |  ETA: 0:00:00Sampling: 100%|█████████████████████████████████████████| Time: 0:00:01
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Simulation-based-calibration--SBC--https-arxiv-dot-org-abs-1804-dot-06788-Talts-et-dot-al-dot--2018-split">

<p>
Did we recover the parameters?
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>ps = []
<span style="color: #3B6EA8;">for</span> sym <span style="color: #3B6EA8;">in</span> [<span style="color: #97365B;">:&#946;</span>, <span style="color: #97365B;">:&#947;</span>, <span style="color: #97365B;">:&#981;&#8315;&#185;</span>]
    p = density(chain_test[:, [sym], :])
    vline!([test_values[sym]])
    push!(ps, p)
<span style="color: #3B6EA8;">end</span>
plot(ps..., layout=(3, 1), size=(600, 400))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/be1c12fbb76e6f039cc149b75842d8ee461b8f89.png" alt="be1c12fbb76e6f039cc149b75842d8ee461b8f89.png" />
</p>
</div>

</div>

<p>
Yay!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Samplers-in-Turing-dot-jl">
<h3 id="2023-01-29-16-57-28-Samplers-in-Turing-dot-jl">Samplers in Turing.jl</h3>
<ul>
<li>Metropolis-Hastings, emcee, SGLD (<a href="https://github.com/TuringLang/AdvancedMH.jl">AdvancedMH.jl</a>)</li>
<li>Hamiltonian Monte Carlo, NUTS (<a href="https://github.com/TuringLang/AdvancedMH.jl">AdvancedHMC.jl</a>)</li>
<li>SMC (<a href="https://github.com/TuringLang/AdvancedPS.jl">AdvancedPS.jl</a>)</li>
<li>Elliptical Slice Sampling (<a href="https://github.com/TuringLang/EllipticalSliceSampling.jl">EllipticalSliceSampling.jl</a>)</li>
<li>Nested sampling (<a href="https://github.com/TuringLang/NestedSamplers.jl">NestedSamplers.jl</a>)</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-Samplers-in-Turing-dot-jl-split">

<p>
You can also combine some of these in Turing.jl
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> LinearAlgebra: I

<span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> linear_regression(X)
    num_params = size(X, 1)
    &#946; ~ MvNormal(ones(num_params))
    &#963;&#178; ~ InverseGamma(2, 3)
    y ~ MvNormal(vec(&#946;' * X), &#963;&#178; * I)
<span style="color: #3B6EA8;">end</span>

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Generate some dummy data.</span>
X = randn(2, 1_000); lin_reg = linear_regression(X); true_vals = rand(lin_reg)

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Condition.</span>
lin_reg_conditioned = lin_reg | (y = true_vals.y,);
</code></pre>
</div>

<p>
We can then do <code>Gibbs</code> but sampling \(β\) using <code>ESS</code> and \(\sigma^2\) using <code>HMC</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain_ess_hmc = sample(lin_reg_conditioned, Gibbs(ESS(<span style="color: #97365B;">:&#946;</span>), HMC(1e-3, 16, <span style="color: #97365B;">:&#963;&#178;</span>)), 1_000)
</code></pre>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Samplers-in-Turing-dot-jl-split">

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>chain_ess_hmc = sample(lin_reg_conditioned, Gibbs(ESS(<span style="color: #97365B;">:&#946;</span>), HMC(1e-3, 16, <span style="color: #97365B;">:&#963;&#178;</span>)), 1_000)
</code></pre>
</div>

<pre class="example">
Sampling:  10%|████▎                                    |  ETA: 0:00:01Sampling:  58%|███████████████████████▊                 |  ETA: 0:00:00Sampling: 100%|█████████████████████████████████████████| Time: 0:00:00
</pre>

<pre class="example">
Chains MCMC chain (1000×4×1 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 1
Samples per chain = 1000
Wall duration     = 3.39 seconds
Compute duration  = 3.39 seconds
parameters        = β[1], β[2], σ²
internals         = lp

Summary Statistics
  parameters      mean       std   naive_se      mcse        ess      rhat   e ⋯
      Symbol   Float64   Float64    Float64   Float64    Float64   Float64     ⋯

        β[1]   -1.6886    0.1124     0.0036    0.0075   211.1299    1.0006     ⋯
        β[2]   -0.7129    0.0581     0.0018    0.0024   433.8817    1.0015     ⋯
          σ²    1.9929    0.0893     0.0028    0.0113    48.7541    1.0021     ⋯
                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5% 
      Symbol   Float64   Float64   Float64   Float64   Float64 

        β[1]   -1.7810   -1.7259   -1.6992   -1.6630   -1.6026
        β[2]   -0.7994   -0.7469   -0.7146   -0.6805   -0.6266
          σ²    1.8287    1.9345    1.9893    2.0446    2.1821
</pre>

<p>
Could potentially lead to improvements
</p>

<p>
<b>NOTE:</b> Usually <i>very</i> difficult to choose sampler parameters in this case
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Samplers-in-Turing-dot-jl-split">

<p>
Means one can also mix discrete and continuous
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> mixture(n)
    cluster ~ filldist(Categorical([0.25, 0.75]), n)
    &#956; ~ MvNormal([-10.0, 10.0], I)
    x ~ arraydist(Normal.(&#956;[cluster], 1))
<span style="color: #3B6EA8;">end</span>

model_mixture = mixture(10)
fake_values_mixture = rand(model_mixture)
model_mixture_conditioned = model_mixture | (x = fake_values_mixture.x, )
chain_discrete = sample(
    model_mixture_conditioned, Gibbs(PG(10, <span style="color: #97365B;">:cluster</span>), HMC(1e-3, 16, <span style="color: #97365B;">:&#956;</span>)), MCMCThreads(), 1_000, 4
)
</code></pre>
</div>

<pre class="example">
Sampling (4 threads):  75%|█████████████████████▊       |  ETA: 0:00:00Sampling (4 threads): 100%|█████████████████████████████| Time: 0:00:00
</pre>

<pre class="example">
Chains MCMC chain (1000×13×4 Array{Float64, 3}):

Iterations        = 1:1:1000
Number of chains  = 4
Samples per chain = 1000
Wall duration     = 9.1 seconds
Compute duration  = 35.2 seconds
parameters        = cluster[1], cluster[2], cluster[3], cluster[4], cluster[5], cluster[6], cluster[7], cluster[8], cluster[9], cluster[10], μ[1], μ[2]
internals         = lp

Summary Statistics
   parameters       mean       std   naive_se      mcse         ess      rhat  ⋯
       Symbol    Float64   Float64    Float64   Float64     Float64   Float64  ⋯

   cluster[1]     1.0245    0.1546     0.0024    0.0135     49.1752    1.0586  ⋯
   cluster[2]     1.0517    0.2215     0.0035    0.0244     24.8047    1.1288  ⋯
   cluster[3]     1.1227    0.3282     0.0052    0.0375     18.5621    1.2743  ⋯
   cluster[4]     1.9995    0.0224     0.0004    0.0004   4002.3197    0.9999  ⋯
   cluster[5]     1.9725    0.1636     0.0026    0.0195     25.6370    1.1311  ⋯
   cluster[6]     1.9835    0.1274     0.0020    0.0139     61.8799    1.0723  ⋯
   cluster[7]     1.2712    0.4447     0.0070    0.0532     10.2500    1.9732  ⋯
   cluster[8]     1.0083    0.0905     0.0014    0.0065    128.4567    1.0179  ⋯
   cluster[9]     1.3710    0.4831     0.0076    0.0588     10.7308    1.8081  ⋯
  cluster[10]     2.0000    0.0000     0.0000    0.0000         NaN       NaN  ⋯
         μ[1]   -10.2644    1.1909     0.0188    0.1496      8.0814    8.8935  ⋯
         μ[2]     9.6664    0.8387     0.0133    0.1037      8.4436    3.7077  ⋯
                                                                1 column omitted

Quantiles
   parameters       2.5%      25.0%      50.0%     75.0%     97.5% 
       Symbol    Float64    Float64    Float64   Float64   Float64 

   cluster[1]     1.0000     1.0000     1.0000    1.0000    1.0000
   cluster[2]     1.0000     1.0000     1.0000    1.0000    2.0000
   cluster[3]     1.0000     1.0000     1.0000    1.0000    2.0000
   cluster[4]     2.0000     2.0000     2.0000    2.0000    2.0000
   cluster[5]     1.0000     2.0000     2.0000    2.0000    2.0000
   cluster[6]     2.0000     2.0000     2.0000    2.0000    2.0000
   cluster[7]     1.0000     1.0000     1.0000    2.0000    2.0000
   cluster[8]     1.0000     1.0000     1.0000    1.0000    1.0000
   cluster[9]     1.0000     1.0000     1.0000    2.0000    2.0000
  cluster[10]     2.0000     2.0000     2.0000    2.0000    2.0000
         μ[1]   -11.8037   -11.3141   -10.4745   -9.3795   -8.2947
         μ[2]     8.4038     8.9560     9.6131   10.4825   11.0633
</pre>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Samplers-in-Turing-dot-jl-split">

<div class="x-small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>ps = []
<span style="color: #3B6EA8;">for</span> (i, realizations) <span style="color: #3B6EA8;">in</span> enumerate(eachcol(Array(group(chain_discrete, <span style="color: #97365B;">:cluster</span>))))
    p = density(realizations, legend=<span style="color: #97365B;">false</span>, ticks=<span style="color: #97365B;">false</span>); vline!(p, [fake_values_mixture.cluster[i]])
    push!(ps, p)
<span style="color: #3B6EA8;">end</span>
plot(ps..., layout=(length(ps) &#247; 2, 2), size=(600, 40 * length(ps)))
</code></pre>
</div>


<div class="figure">
<p><img src="assets/outputs/f64dea8a5533f00397817ee6703ff49dcb105c25.png" alt="f64dea8a5533f00397817ee6703ff49dcb105c25.png" />
</p>
</div>

</div>

<p>
Again, this is difficult to get to work properly on non-trivial examples
</p>

<p>
<span class="underline">But</span> it is possible
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Other-utilities-for-Turing-dot-jl">
<h3 id="2023-01-29-16-57-28-Other-utilities-for-Turing-dot-jl">Other utilities for Turing.jl</h3>
<ul>
<li><a href="https://github.com/TuringLang/TuringGLM.jl">TuringGLM.jl</a>: GLMs using the formula-syntax from R but using Turing.jl under the hood</li>
<li><a href="https://github.com/TuringLang/TuringBenchmarking.jl">TuringBenchmarking.jl</a>: useful for benchmarking Turing.jl models</li>
<li><a href="https://github.com/TuringLang/TuringCallbacks.jl">TuringCallbacks.jl</a>: on-the-fly visualizations using <code>tensorboard</code></li>

</ul>



<div class="figure">
<p><img src="assets/attachments/2023-01-25_20-50-11_tensorboard_demo_histograms_screen.png" alt="2023-01-25_20-50-11_tensorboard_demo_histograms_screen.png" width="600px" />
</p>
</div>


</section>
<section id="slide-2023-01-29-16-57-28-Downsides-of-using-Turing-dot-jl">
<h3 id="2023-01-29-16-57-28-Downsides-of-using-Turing-dot-jl">Downsides of using Turing.jl</h3>
<ul>
<li class="fragment appear">Don't do any depedency-extraction of the model ⟹ can't do things like automatic marginalization
<ul>
<li><i>But</i> it's not impossible; just a matter of development effort</li>
<li>Ongoing work in <code>TuringLang</code> to make a <a href="https://www.mrc-bsu.cam.ac.uk/software/bugs/">BUGS</a> compatible model "compiler" / parser (in colab with Andrew Thomas &amp; others)</li>

</ul></li>
<li class="fragment appear">NUTS performance is at the mercy of AD in Julia</li>
<li class="fragment appear">You <span class="underline">can</span> put anything in your model, but whether you <span class="underline">should</span> is a another matter</li>

</ul>

</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Benchmarking">
<h2 id="2023-01-29-16-57-28-Benchmarking">Benchmarking</h2>
</section>
<section id="slide-2023-01-29-16-57-28-Benchmarking-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> SciMLSensitivity
<span style="color: #3B6EA8;">using</span> BenchmarkTools
<span style="color: #3B6EA8;">using</span> TuringBenchmarking
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> ReverseDiff, Zygote
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>suite = TuringBenchmarking.make_turing_suite(
    model_conditioned;
    adbackends=[
        TuringBenchmarking.ForwardDiffAD{40,<span style="color: #97365B;">true</span>}(),
        TuringBenchmarking.ReverseDiffAD{<span style="color: #97365B;">false</span>}(),
        TuringBenchmarking.ZygoteAD()
    ]
);
run(suite)
</code></pre>
</div>

<pre class="example">
2-element BenchmarkTools.BenchmarkGroup:
  tags: []
  "linked" =&gt; 4-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(368.161 μs)
	  "evaluation" =&gt; Trial(28.270 μs)
	  "Turing.Essential.ForwardDiffAD{40, true}()" =&gt; Trial(122.734 μs)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(3.121 ms)
  "not_linked" =&gt; 4-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(454.382 μs)
	  "evaluation" =&gt; Trial(27.078 μs)
	  "Turing.Essential.ForwardDiffAD{40, true}()" =&gt; Trial(151.882 μs)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(2.885 ms)
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-More-data">
<h3 id="2023-01-29-16-57-28-More-data">More data</h3>
<p>
Let's add some more timesteps to make it a more interesting
</p>

<p>
How about 10 000?
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> We now use 10 000 days instead of just 14.</span>
model_fake = epidemic_model(SIRProblem(N; tspan=(0, 10_000)), prior_improved);
</code></pre>
</div>

<p>
From this we'll generate some fake data
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>res = rand(model_fake)
model_fake_conditioned = model_fake | (in_bed = res.in_bed,);
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-More-data-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_fake_conditioned().infected
</code></pre>
</div>

<pre class="example">
10000-element Vector{Float64}:
   2.7975983440413223
   7.748418187214023
  20.88236766334096
  52.45691560357974
 112.4569199051879
 183.12340579979855
 215.7666283305088
 196.72101213557013
 153.56623546042505
 110.06252620822383
  75.3051039014327
  50.188689698069695
  32.953929054350986
   ⋮
  -4.200904016575503e-16
  -3.884354912599255e-16
  -3.5677074858373597e-16
  -3.2509617362904785e-16
  -2.934117663958071e-16
  -2.6171752688401963e-16
  -2.300134550937096e-16
  -1.9829955102488296e-16
  -1.6657581467747957e-16
  -1.3484224605157163e-16
  -1.0309884514710501e-16
  -7.134561196412778e-17
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-More-data-split">

<p>
And run some benchmarks!
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>suite = TuringBenchmarking.make_turing_suite(
    model_fake_conditioned;
    adbackends=[
        TuringBenchmarking.ForwardDiffAD{40,<span style="color: #97365B;">true</span>}(),
        TuringBenchmarking.ReverseDiffAD{<span style="color: #97365B;">false</span>}(),
        TuringBenchmarking.ZygoteAD()
    ]
);
run(suite)
</code></pre>
</div>

<pre class="example">
2-element BenchmarkTools.BenchmarkGroup:
  tags: []
  "linked" =&gt; 4-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(42.524 ms)
	  "evaluation" =&gt; Trial(2.020 ms)
	  "Turing.Essential.ForwardDiffAD{40, true}()" =&gt; Trial(3.687 ms)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(29.392 ms)
  "not_linked" =&gt; 4-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(40.269 ms)
	  "evaluation" =&gt; Trial(2.035 ms)
	  "Turing.Essential.ForwardDiffAD{40, true}()" =&gt; Trial(3.826 ms)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(32.606 ms)
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-More-data-split">

<p>
What if we use a different <code>sensealg</code> in <code>solve</code>?
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> epidemic_model(
    problem_wrapper::<span style="color: #9A7500;">AbstractEpidemicProblem</span>,
    prior;
    sensealg=ForwardDiffSensitivity()  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> This will be passed to `solve`.</span>
)
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">And use `@submodel` to embed the `prior` in our model.</span>
    <span style="color: #3B6EA8; font-weight: bold;">@submodel</span> p = prior(problem_wrapper)

    &#981;&#8315;&#185; ~ Exponential(1/5)
    &#981; = inv(&#981;&#8315;&#185;)

    problem_new = remake(problem_wrapper.problem, p=p)    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Replace parameters `p`.</span>
    <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Allowed to use a different `sensealg`</span>
    sol = solve(problem_new; saveat=1, sensealg=sensealg) <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Solve!</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Return early if integration failed.</span>
    <span style="color: #3B6EA8;">if</span> !issuccess(sol)
        Turing.<span style="color: #3B6EA8; font-weight: bold;">@addlogprob!</span> -<span style="color: #97365B;">Inf</span>  <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Causes automatic rejection.</span>
        <span style="color: #3B6EA8;">return</span> <span style="color: #97365B;">nothing</span>
    <span style="color: #3B6EA8;">end</span>

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Extract the `infected`.</span>
    sol_for_observed = infected(problem_wrapper, sol)[2:<span style="color: #3B6EA8;">end</span>]

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">`arraydist` is faster for larger dimensional problems,</span>
    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">and it does not require explicit allocation of the vector.</span>
    in_bed ~ arraydist(NegativeBinomial2.(sol_for_observed .+ 1e-5, &#981;))

    &#946;, &#947; = p[1:2]
    <span style="color: #3B6EA8;">return</span> (R0 = &#946; / &#947;, recovery_time = 1 / &#947;, infected = sol_for_observed)
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
epidemic_model (generic function with 3 methods)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-More-data-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim>model_fake = epidemic_model(
    SIRProblem(N; tspan=(0, 10_000)),
    prior_improved;
    sensealg=ForwardSensitivity()  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> `ForwardSensitivity` is differnt from `ForwardDiffSensitivity`</span>
);
model_fake_conditioned = model_fake | (in_bed = res.in_bed,);
</code></pre>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-More-data-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> AFAIK `ForwardSensitivity` has no effect when used with `ForwardDiff.jl`.</span>
suite = TuringBenchmarking.make_turing_suite(
    model_fake_conditioned;
    adbackends=[
        TuringBenchmarking.ReverseDiffAD{<span style="color: #97365B;">false</span>}(),
        TuringBenchmarking.ZygoteAD()
    ]
);
run(suite)
</code></pre>
</div>

<pre class="example">
2-element BenchmarkTools.BenchmarkGroup:
  tags: []
  "linked" =&gt; 3-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(21.775 ms)
	  "evaluation" =&gt; Trial(2.104 ms)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(10.506 ms)
  "not_linked" =&gt; 3-element BenchmarkTools.BenchmarkGroup:
	  tags: []
	  "Turing.Essential.ReverseDiffAD{false}()" =&gt; Trial(23.455 ms)
	  "evaluation" =&gt; Trial(1.889 ms)
	  "Turing.Essential.ZygoteAD()" =&gt; Trial(11.741 ms)
</pre>

<p>
Okay, so it's faster but ForwardDiff.jl still wins
</p>

<p>
(which is not surprising on such a low-dimensional problem)
</p>


</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Case-spatio-temporal-COVID-modeling-in-UK">
<h2 id="2023-01-29-16-57-28-Case-spatio-temporal-COVID-modeling-in-UK">Case: spatio-temporal COVID modeling in UK</h2>

<div class="figure">
<p><img src="assets/attachments/2023-01-26_15-47-56_Screenshot_20230126_154747.png" alt="2023-01-26_15-47-56_Screenshot_20230126_154747.png" width="600px" />
</p>
</div>

</section>
<section id="slide-2023-01-29-16-57-28-Case-spatio-temporal-COVID-modeling-in-UK-split">

<p>
Main model looked like this
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-25_02-23-23_Screenshot_20230125_022312.png" alt="2023-01-25_02-23-23_Screenshot_20230125_022312.png" width="600px" />
</p>
</div>

<p>
Roughly 50 000 parameters
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Case-spatio-temporal-COVID-modeling-in-UK-split">

<p>
Output, for different approaches, looked like this
</p>

<video controls width="1000">
    <source src="file:///home/tor/Dropbox/tmp/epimap-vs-epimap-debiased-vs-debiased-different-coloring.mp4" type="video/mp4">
    Sorry, your browser doesn't support embedded videos.
</video>

</section>
<section id="slide-2023-01-29-16-57-28-Case-spatio-temporal-COVID-modeling-in-UK-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">GP-model for R-value.</span>
<span style="color: #3B6EA8; font-weight: bold;">@submodel</span> R = SpatioTemporalGP(K_spatial, K_local, K_time, T; &#963;_spatial, &#963;_local, &#961;_spatial, &#961;_time)

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Latent infections.</span>
<span style="color: #3B6EA8; font-weight: bold;">@submodel</span> X = RegionalFlux(F_id, F_in, F_out, W, R, X_cond, T; days_per_step, &#963;_&#958;)

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Likelihood.</span>
<span style="color: #3B6EA8; font-weight: bold;">@submodel</span> C = NegBinomialWeeklyAdjustedTesting(C, X, D, num_cond, T)
</code></pre>
</div>

<p>
with
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@model</span> <span style="color: #3B6EA8;">function</span> SpatioTemporalGP(
    K_spatial, K_local, K_time,
    ::<span style="color: #9A7500;">Type</span>{T} = Float64;
) <span style="color: #3B6EA8;">where</span> {T}
    num_steps = size(K_time, 1)
    num_regions = size(K_spatial, 1)

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Length scales</span>
    &#961;_spatial ~ &#119977;&#8330;(T(0), T(5))
    &#961;_time ~ &#119977;&#8330;(T(0), T(5))

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Scales</span>
    &#963;_spatial ~ &#119977;&#8330;(T(0), T(0.5))
    &#963;_local ~ &#119977;&#8330;(T(0), T(0.5))

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">GP</span>
    E_vec ~ MvNormal(num_regions * num_steps, one(T))
    E = reshape(E_vec, (num_regions, num_steps))

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Get cholesky decomps using precomputed kernel matrices</span>
    L_space = spatial_L(K_spatial, K_local, &#963;_spatial, &#963;_local, &#961;_spatial)
    U_time = time_U(K_time, &#961;_time)

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Obtain realization of log-R.</span>
    f = L_space * E * U_time

    <span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Compute R.</span>
    R = exp.(f)
    <span style="color: #3B6EA8;">return</span> R
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

</div>


</section>
</section>
<section>
<section id="slide-2023-01-29-16-57-28-Julia-The-Good-the-Bad-and-the-Ugly">
<h2 id="2023-01-29-16-57-28-Julia-The-Good-the-Bad-and-the-Ugly">Julia: The Good, the Bad, and the Ugly</h2>
<p>
An honest take from a little 27-year old Norwegian boy
</p>

</section>
<section id="slide-2023-01-29-16-57-28-The-Good">
<h4 id="2023-01-29-16-57-28-The-Good">The Good</h4>
<ul>
<li>Speed</li>
<li>Composability (thank you multiple dispatch)</li>
<li>No need to tie yourself to an underlying computational framework</li>
<li>Interactive</li>
<li>Transparency</li>
<li>Very easy to call into other languages</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-Speed">
<h4 id="2023-01-29-16-57-28-Speed">Speed</h4>
<p>
I think you got this already&#x2026;
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Composability">
<h4 id="2023-01-29-16-57-28-Composability">Composability</h4>
<p>
We've seen some of that
</p>

<p>
Defining <code>infected(problem_wrapper, u)</code> allowed us to abstract away how to extract the compartment of interest
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Transparency">
<h4 id="2023-01-29-16-57-28-Transparency">Transparency</h4>
<p>
For starters, almost all the code you'll end up using is pure Julia
</p>

<p>
Hence, you can always look at the code
</p>

<p>
You can find the implementation by using <code>@which</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Without arguments</span>
<span style="color: #3B6EA8; font-weight: bold;">@which</span> sum
</code></pre>
</div>

<pre class="example">
Base
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">With arguments</span>
<span style="color: #3B6EA8; font-weight: bold;">@which</span> sum([1.0])
</code></pre>
</div>

<pre class="example">
sum(a::AbstractArray; dims, kw...) in Base at reducedim.jl:994
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Transparency-split">

<p>
And yeah, you can even look into the macros
</p>

<div class="small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@macroexpand</span> <span style="color: #3B6EA8; font-weight: bold;">@model</span> f() = x ~ Normal()
</code></pre>
</div>

<pre class="example">
quote
    function f(__model__::DynamicPPL.Model, __varinfo__::DynamicPPL.AbstractVarInfo, __context__::AbstractPPL.AbstractContext; )
        #= In[113]:1 =#
        begin
            var"##dist#1413" = Normal()
            var"##vn#1410" = (DynamicPPL.resolve_varnames)((AbstractPPL.VarName){:x}(), var"##dist#1413")
            var"##isassumption#1411" = begin
                    if (DynamicPPL.contextual_isassumption)(__context__, var"##vn#1410")
                        if !((DynamicPPL.inargnames)(var"##vn#1410", __model__)) || (DynamicPPL.inmissings)(var"##vn#1410", __model__)
                            true
                        else
                            x === missing
                        end
                    else
                        false
                    end
                end
            begin
                #= /home/tor/.julia/packages/DynamicPPL/WBmMU/src/compiler.jl:539 =#
                var"##retval#1415" = if var"##isassumption#1411"
                        begin
                            (var"##value#1414", __varinfo__) = (DynamicPPL.tilde_assume!!)(__context__, (DynamicPPL.unwrap_right_vn)((DynamicPPL.check_tilde_rhs)(var"##dist#1413"), var"##vn#1410")..., __varinfo__)
                            x = var"##value#1414"
                            var"##value#1414"
                        end
                    else
                        if !((DynamicPPL.inargnames)(var"##vn#1410", __model__))
                            x = (DynamicPPL.getvalue_nested)(__context__, var"##vn#1410")
                        end
                        (var"##value#1412", __varinfo__) = (DynamicPPL.tilde_observe!!)(__context__, (DynamicPPL.check_tilde_rhs)(var"##dist#1413"), x, var"##vn#1410", __varinfo__)
                        var"##value#1412"
                    end
                #= /home/tor/.julia/packages/DynamicPPL/WBmMU/src/compiler.jl:540 =#
                return (var"##retval#1415", __varinfo__)
            end
        end
    end
    begin
        $(Expr(:meta, :doc))
        function f(; )
            #= In[113]:1 =#
            return (DynamicPPL.Model)(f, NamedTuple(), NamedTuple())
        end
    end
end
</pre>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Transparency-split">

<p>
I told you didn't want to see that.
</p>

<p>
Can make it <i>a bit</i> cleaner by removing linenums:
</p>

<div class="x-small-text">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@macroexpand</span>(<span style="color: #3B6EA8; font-weight: bold;">@model</span> f() = x ~ Normal()) |&gt; Base.remove_linenums!
</code></pre>
</div>

<pre class="example">
quote
    function f(__model__::DynamicPPL.Model, __varinfo__::DynamicPPL.AbstractVarInfo, __context__::AbstractPPL.AbstractContext; )
        begin
            var"##dist#1419" = Normal()
            var"##vn#1416" = (DynamicPPL.resolve_varnames)((AbstractPPL.VarName){:x}(), var"##dist#1419")
            var"##isassumption#1417" = begin
                    if (DynamicPPL.contextual_isassumption)(__context__, var"##vn#1416")
                        if !((DynamicPPL.inargnames)(var"##vn#1416", __model__)) || (DynamicPPL.inmissings)(var"##vn#1416", __model__)
                            true
                        else
                            x === missing
                        end
                    else
                        false
                    end
                end
            begin
                var"##retval#1421" = if var"##isassumption#1417"
                        begin
                            (var"##value#1420", __varinfo__) = (DynamicPPL.tilde_assume!!)(__context__, (DynamicPPL.unwrap_right_vn)((DynamicPPL.check_tilde_rhs)(var"##dist#1419"), var"##vn#1416")..., __varinfo__)
                            x = var"##value#1420"
                            var"##value#1420"
                        end
                    else
                        if !((DynamicPPL.inargnames)(var"##vn#1416", __model__))
                            x = (DynamicPPL.getvalue_nested)(__context__, var"##vn#1416")
                        end
                        (var"##value#1418", __varinfo__) = (DynamicPPL.tilde_observe!!)(__context__, (DynamicPPL.check_tilde_rhs)(var"##dist#1419"), x, var"##vn#1416", __varinfo__)
                        var"##value#1418"
                    end
                return (var"##retval#1421", __varinfo__)
            end
        end
    end
    begin
        $(Expr(:meta, :doc))
        function f(; )
            return (DynamicPPL.Model)(f, NamedTuple(), NamedTuple())
        end
    end
end
</pre>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Transparency-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #29838D;">f</span>(x) = 2x
</code></pre>
</div>

<pre class="example">
f (generic function with 1 method)
</pre>


<p>
You can inspect the type-inferred and lowered code
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@code_typed</span> f(1)
</code></pre>
</div>

<pre class="example">
CodeInfo(
1 ─ %1 = Base.mul_int(2, x)::Int64
└──      return %1
) =&gt; Int64
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Transparency-split">

<p>
You can inspect the LLVM code
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@code_llvm</span> f(1)
</code></pre>
</div>

<pre class="example">
;  @ In[115]:1 within `f`
define i64 @julia_f_52767(i64 signext %0) #0 {
top:
; ┌ @ int.jl:88 within `*`
   %1 = shl i64 %0, 1
; └
  ret i64 %1
}
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Transparency-split">

<p>
And even the resulting machine code
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@code_native</span> f(1)
</code></pre>
</div>

<pre class="example">
	.text
	.file	"f"
	.globl	julia_f_52804                   # -- Begin function julia_f_52804
	.p2align	4, 0x90
	.type	julia_f_52804,@function
julia_f_52804:                          # @julia_f_52804
; ┌ @ In[115]:1 within `f`
	.cfi_startproc
# %bb.0:                                # %top
; │┌ @ int.jl:88 within `*`
	leaq	(%rdi,%rdi), %rax
; │└
	retq
.Lfunc_end0:
	.size	julia_f_52804, .Lfunc_end0-julia_f_52804
	.cfi_endproc
; └
                                        # -- End function
	.section	".note.GNU-stack","",@progbits
</pre>

<p>
It really just depends on which level of "I hate my life" you're currently at
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Calling-into-other-languages">
<h4 id="2023-01-29-16-57-28-Calling-into-other-languages">Calling into other languages</h4>
<ul>
<li><a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/">C and Fortran comes built-in stdlib</a></li>
<li><a href="https://juliainterop.github.io/RCall.jl/stable/">RCall.jl</a>: call into <code>R</code></li>
<li><a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a>: call into <code>python</code></li>
<li>Etc.</li>

</ul>

<p>
When working with <code>Array</code>, etc. memory is usually shared ⟹ fairly low overhead
</p>

</section>
<section id="slide-2023-01-29-16-57-28-C-and-Fortran">
<h4 id="2023-01-29-16-57-28-C-and-Fortran">C and Fortran</h4>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Define the Julia function</span>
<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">mycompare</span>(a, b)::<span style="color: #9A7500;">Cint</span>
    println(<span style="color: #4F894C;">"mycompare($a, $b)"</span>)  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Let's look at the comparisons made.</span>
    <span style="color: #3B6EA8;">return</span> (a &lt; b) <span style="color: #3B6EA8;">?</span> -1 : ((a &gt; b) ? +1 <span style="color: #3B6EA8;">:</span> 0)
<span style="color: #3B6EA8;">end</span>

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Get the corresponding C function pointer.</span>
mycompare_c = <span style="color: #3B6EA8; font-weight: bold;">@cfunction</span>(mycompare, Cint, (Ref{Cdouble}, Ref{Cdouble}))

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Array to sort.</span>
arr = [1.3, -2.7, 4.4, 3.1];

<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Call in-place quicksort.</span>
<span style="color: #29838D;">ccall</span>(<span style="color: #97365B;">:qsort</span>, <span style="color: #97365B;">Cvoid</span>, (Ptr{Cdouble}, Csize_t, Csize_t, Ptr{<span style="color: #97365B;">Cvoid</span>}),
      arr, length(arr), sizeof(eltype(arr)), mycompare_c)
</code></pre>
</div>

<pre class="example">
mycompare(1.3, -2.7)
mycompare(4.4, 3.1)
mycompare(-2.7, 3.1)
mycompare(1.3, 3.1)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">All sorted!</span>
arr
</code></pre>
</div>

<pre class="example">
4-element Vector{Float64}:
 -2.7
  1.3
  3.1
  4.4
</pre>


<p>
<a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/#Creating-C-Compatible-Julia-Function-Pointers">Example is from Julia docs</a>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-The-Bad">
<h4 id="2023-01-29-16-57-28-The-Bad">The Bad</h4>
<p>
Sometimes
</p>
<ul>
<li>your code might just slow down without a seemingly good reason,</li>
<li>someone did bad, and Julia can't tell which method to call, or</li>
<li>someone forces the Julia compiler to compile insane amounts of code</li>

</ul>

</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow">
<h4 id="2023-01-29-16-57-28-Why-is-my-code-suddenly-slow">"Why is my code suddenly slow?"</h4>
<p>
One word: <b>type-instability</b>
</p>

<p>
Sometimes the Julia compiler can't quite infer what types fully
</p>

<div class="fragment (appear)">

<p>
<b>Result:</b> python-like performance (for those particular function calls)
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> this is NOT `const`, and so it could become some other type</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">at any given point without `my_func` knowing about it!</span>
global_variable = 1
<span style="color: #29838D;">my_func_unstable</span>(x) = global_variable * x
</code></pre>
</div>

<pre class="example">
my_func_unstable (generic function with 1 method)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@btime</span> my_func_unstable(2.0);
</code></pre>
</div>

<pre class="example">
30.668 ns (2 allocations: 32 bytes)
</pre>


</div>

</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow-split">

<p>
Luckily there are tools for inspecting this
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@code_warntype</span> my_func_unstable(2.0)
</code></pre>
</div>

<pre class="example">
MethodInstance for my_func_unstable(::Float64)
  from my_func_unstable(x) in Main at In[121]:4
Arguments
  #self#::Core.Const(my_func_unstable)
  x::Float64
Body::Any
1 ─ %1 = (Main.global_variable * x)::Any
└──      return %1

</pre>


<p>
See that <code>Any</code> there? <span class="underline">'tis a big no-no!</span>
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow-split">

<p>
Once discovered, it can be fixed
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">const</span> constant_global_variable = 1
<span style="color: #29838D;">my_func_fixed</span>(x) = constant_global_variable * x
<span style="color: #3B6EA8; font-weight: bold;">@code_warntype</span> my_func_fixed(2.0)
</code></pre>
</div>

<pre class="example">
MethodInstance for my_func_fixed(::Float64)
  from my_func_fixed(x) in Main at In[124]:2
Arguments
  #self#::Core.Const(my_func_fixed)
  x::Float64
Body::Float64
1 ─ %1 = (Main.constant_global_variable * x)::Float64
└──      return %1

</pre>


<p>
So long Python performance!
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@btime</span> my_func_fixed(2.0);
</code></pre>
</div>

<pre class="example">
1.696 ns (0 allocations: 0 bytes)
</pre>



</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow-split">

<p>
<i>But</i> this is not always so easy to discover (though this is generally rare)
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #97365B; font-weight: bold;">HACK:</span><span style="color: #8b94a5;"> Here we explicitly tell Julia what type `my_func_unstable`</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">returns. This is _very_ rarely a good idea because it just hides</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">the underlying problem from `@code_warntype`!</span>
<span style="color: #29838D;">my_func_forced</span>(x) = my_func_unstable(x)::<span style="color: #9A7500;">typeof</span>(x)
<span style="color: #3B6EA8; font-weight: bold;">@code_warntype</span> my_func_forced(2.0)
</code></pre>
</div>

<pre class="example">
MethodInstance for my_func_forced(::Float64)
  from my_func_forced(x) in Main at In[126]:4
Arguments
  #self#::Core.Const(my_func_forced)
  x::Float64
Body::Float64
1 ─ %1 = Main.my_func_unstable(x)::Any
│   %2 = Main.typeof(x)::Core.Const(Float64)
│   %3 = Core.typeassert(%1, %2)::Float64
└──      return %3
</pre>

<p>
We can still see the <code>Any</code> in there, but on a first glance it looks like <code>my_func_forced</code> is type-stable
</p>

<p>
There are more natural cases where this might occur, e.g. unfortunate closures deep in your callstack
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow-split">

<p>
To discovery these there are a couple of more advanced tools:
</p>
<ul>
<li><a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu.jl</a>: Allows you to step through your code like a debugger and perform <code>@code_warntype</code></li>
<li><a href="https://github.com/aviatesk/JET.jl">JET.jl</a>: Experimental package which attempts to automate the process</li>

</ul>

<p>
And even simpler: profile using <a href="https://github.com/timholy/ProfileView.jl">ProfileView.jl</a> and look for code-paths that <i>should</i> be fast but take up a lot of the runtime
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Why-is-my-code-suddenly-slow-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">using</span> ProfileView
</code></pre>
</div>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@profview</span> foreach(_ -&gt; my_func_unstable(2.0), 1_000_000)
</code></pre>
</div>


<div class="figure">
<p><img src="assets/attachments/2023-01-25_01-16-13_Screenshot_20230125_011603.png" alt="2023-01-25_01-16-13_Screenshot_20230125_011603.png" height="350px" />
</p>
</div>

<p>
Note that there's no sign of multiplication here
</p>

<p>
But most of the runtime is the <code>./reflection.jl</code> at the top there
</p>

<p>
That's Julia looking up the type at runtime
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Method-ambiguity">
<h4 id="2023-01-29-16-57-28-Method-ambiguity">Method ambiguity</h4>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #29838D;">ambiguous_function</span>(x, y::<span style="color: #9A7500;">Int</span>) = y
<span style="color: #29838D;">ambiguous_function</span>(x::<span style="color: #9A7500;">Int</span>, y) = x

<span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> Here we have `ambiguous_function(x::Int, y::Int)`</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Which one should we hit?!</span>
ambiguous_function(1, 2)
</code></pre>
</div>

<pre class="example">
MethodError: ambiguous_function(::Int64, ::Int64) is ambiguous. Candidates:
  ambiguous_function(x, y::Int64) in Main at In[128]:1
  ambiguous_function(x::Int64, y) in Main at In[128]:2
Possible fix, define
  ambiguous_function(::Int64, ::Int64)

Stacktrace:
 [1] top-level scope
   @ In[128]:6
</pre>

<p>
But here Julia warns us, and so we can fix this by just doing as it says: define <code>ambiguous_function(::Int64, ::Int64)</code>
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #29838D;">ambiguous_function</span>(::<span style="color: #9A7500;">Int64</span>, ::<span style="color: #9A7500;">Int64</span>) = <span style="color: #4F894C;">"neato"</span>
ambiguous_function(1, 2)
</code></pre>
</div>

<pre class="example">
"neato"
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Long-compilation-times">
<h4 id="2023-01-29-16-57-28-Long-compilation-times">Long compilation times</h4>
<p>
In Julia, for better or worse, we can generate code
</p>

<p>
<b>Problem:</b> it can be <i>lots</i> of code of we really want to
</p>

<p>
<b>Result:</b> first execution can be <i>slow</i>
</p>

<div class="fragment (appear)">

<p>
<b>Time to first plot (TTFP)</b> is Julia's worst enemy
</p>

<p>
But things are always improving
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-25_01-29-05_Screenshot_20230125_012853.png" alt="2023-01-25_01-29-05_Screenshot_20230125_012853.png" />
</p>
</div>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated">
<h4 id="2023-01-29-16-57-28-Another-example-mis-use-of-generated">Another example: mis-use of <code>@generated</code></h4>
<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> `@generated` only has access to static information, e.g. types of arguments.</span>
<span style="color: #8b94a5;"># </span><span style="color: #8b94a5;">Here I'm using the special type `Val` to make a number `N` static.</span>
<span style="color: #3B6EA8; font-weight: bold;">@generated</span> <span style="color: #3B6EA8;">function</span> unrolled_addition(::<span style="color: #9A7500;">Val</span>{N}) <span style="color: #3B6EA8;">where</span> {N}
    expr = Expr(<span style="color: #97365B;">:block</span>)
    push!(expr.args, :(x = 0))
    <span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:N
        push!(expr.args, :(x += $(3.14 * i)))
    <span style="color: #3B6EA8;">end</span>

    <span style="color: #3B6EA8;">return</span> expr
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
unrolled_addition (generic function with 1 method)
</pre>


<p>
When I call this with some <code>Val(N)</code>, Julia will execute this <i>at compile-time</i>!
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> At runtime, it then just returns the result immediately</span>
<span style="color: #3B6EA8; font-weight: bold;">@code_typed</span> unrolled_addition(Val(10))
</code></pre>
</div>

<pre class="example">
CodeInfo(
1 ─     return 172.70000000000002
) =&gt; Float64
</pre>


<p>
But if I just change the value <code>10</code> to <code>11</code>, it's a <i>completely</i> different type!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated-split">

<p>
So Julia has to compile <code>unrolled_addition</code> from scratch
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@time</span> <span style="color: #3B6EA8; font-weight: bold;">@eval</span> unrolled_addition(Val(11));
</code></pre>
</div>

<pre class="example">
0.010027 seconds (11.61 k allocations: 654.885 KiB, 8.32% compilation time)
</pre>


<p>
Or a bit crazier
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@time</span> <span style="color: #3B6EA8; font-weight: bold;">@eval</span> unrolled_addition(Val(10_001));
</code></pre>
</div>

<pre class="example">
0.429549 seconds (1.19 M allocations: 48.946 MiB, 99.94% compilation time)
</pre>


<p>
Here it took ~0.4s, of which 99.95% was compilation time
</p>

<p>
I think you get the idea
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated-split">

<p>
But boy is it fast to run!
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@btime</span> unrolled_addition(Val(10_001));
</code></pre>
</div>

<pre class="example">
1.637 ns (0 allocations: 0 bytes)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">not_unrolled_addition</span>(N)
    x = 0
    <span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:N
        x += 3.14 * i
    <span style="color: #3B6EA8;">end</span>

    <span style="color: #3B6EA8;">return</span> x
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
not_unrolled_addition (generic function with 1 method)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@btime</span> not_unrolled_addition(10_001);
</code></pre>
</div>

<pre class="example">
11.138 μs (0 allocations: 0 bytes)
</pre>


</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated-split">

<p>
<b>Funny side-note:</b> at first I did the following
</p>

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@generated</span> <span style="color: #3B6EA8;">function</span> unrolled_addition_old(::<span style="color: #9A7500;">Val</span>{N}) <span style="color: #3B6EA8;">where</span> {N}
    expr = Expr(<span style="color: #97365B;">:block</span>)
    push!(expr.args, :(x = 0))
    <span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:N
        push!(expr.args, :(x += <span style="color: #97365B;">$i</span>))  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> No 3.14!</span>
    <span style="color: #3B6EA8;">end</span>
    <span style="color: #3B6EA8;">return</span> expr
<span style="color: #3B6EA8;">end</span>
<span style="color: #3B6EA8;">function</span> <span style="color: #29838D;">not_unrolled_addition_old</span>(N)
    x = 0
    <span style="color: #3B6EA8;">for</span> i <span style="color: #3B6EA8;">=</span> 1:N
        x += i  <span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> No 3.14!</span>
    <span style="color: #3B6EA8;">end</span>
    <span style="color: #3B6EA8;">return</span> x
<span style="color: #3B6EA8;">end</span>
</code></pre>
</div>

<pre class="example">
not_unrolled_addition_old (generic function with 1 method)
</pre>


<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #3B6EA8; font-weight: bold;">@btime</span> unrolled_addition_old(Val(10_001));
<span style="color: #3B6EA8; font-weight: bold;">@btime</span> not_unrolled_addition_old(10_001);
</code></pre>
</div>

<pre class="example">
1.538 ns (0 allocations: 0 bytes)
3.495 ns (0 allocations: 0 bytes)
</pre>


<p>
LLVM probably recognized the pattern of <code>not_unrolled_addition_old</code> and unrolls it for us
</p>

<p>
Let's check!
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> The one LLVM failed to unroll</span>
<span style="color: #3B6EA8; font-weight: bold;">@code_llvm</span> not_unrolled_addition(10_001)
</code></pre>
</div>

<pre class="example">
;  @ In[135]:1 within `not_unrolled_addition`
define { {}*, i8 } @julia_not_unrolled_addition_53856([8 x i8]* noalias nocapture align 8 dereferenceable(8) %0, i64 signext %1) #0 {
top:
;  @ In[135]:3 within `not_unrolled_addition`
; ┌ @ range.jl:5 within `Colon`
; │┌ @ range.jl:393 within `UnitRange`
; ││┌ @ range.jl:400 within `unitrange_last`
     %.inv = icmp sgt i64 %1, 0
     %. = select i1 %.inv, i64 %1, i64 0
; └└└
  br i1 %.inv, label %L18.preheader, label %union_move16

L18.preheader:                                    ; preds = %top
;  @ In[135]:5 within `not_unrolled_addition`
; ┌ @ range.jl:883 within `iterate`
; │┌ @ promotion.jl:477 within `==`
    %.not30 = icmp eq i64 %., 1
; └└
  br i1 %.not30, label %union_move, label %L51

L51:                                              ; preds = %L51, %L18.preheader
  %value_phi1032 = phi double [ %value_phi10, %L51 ], [ 3.140000e+00, %L18.preheader ]
  %value_phi431 = phi i64 [ %2, %L51 ], [ 1, %L18.preheader ]
; ┌ @ range.jl:883 within `iterate`
   %2 = add i64 %value_phi431, 1
; └
;  @ In[135]:4 within `not_unrolled_addition`
; ┌ @ promotion.jl:389 within `*`
; │┌ @ promotion.jl:359 within `promote`
; ││┌ @ promotion.jl:336 within `_promote`
; │││┌ @ number.jl:7 within `convert`
; ││││┌ @ float.jl:146 within `Float64`
       %3 = sitofp i64 %2 to double
; │└└└└
; │ @ promotion.jl:389 within `*` @ float.jl:385
   %4 = fmul double %3, 3.140000e+00
; └
;  @ In[135] within `not_unrolled_addition`
  %value_phi10 = fadd double %value_phi1032, %4
;  @ In[135]:5 within `not_unrolled_addition`
; ┌ @ range.jl:883 within `iterate`
; │┌ @ promotion.jl:477 within `==`
    %.not = icmp eq i64 %2, %.
; └└
  br i1 %.not, label %L18.union_move_crit_edge, label %L51

post_union_move:                                  ; preds = %union_move16, %union_move
  %tindex_phi1429 = phi i8 [ 2, %union_move16 ], [ 1, %union_move ]
;  @ In[135]:7 within `not_unrolled_addition`
  %5 = insertvalue { {}*, i8 } { {}* null, i8 undef }, i8 %tindex_phi1429, 1
  ret { {}*, i8 } %5

L18.union_move_crit_edge:                         ; preds = %L51
;  @ In[135]:5 within `not_unrolled_addition`
  %phi.cast = bitcast double %value_phi10 to i64
  br label %union_move

union_move:                                       ; preds = %L18.union_move_crit_edge, %L18.preheader
  %value_phi10.lcssa = phi i64 [ %phi.cast, %L18.union_move_crit_edge ], [ 4614253070214989087, %L18.preheader ]
;  @ In[135]:7 within `not_unrolled_addition`
  %6 = bitcast [8 x i8]* %0 to i64*
  store i64 %value_phi10.lcssa, i64* %6, align 8
  br label %post_union_move

union_move16:                                     ; preds = %top
  %7 = bitcast [8 x i8]* %0 to i64*
  store i64 0, i64* %7, align 8
  br label %post_union_move
}
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-Another-example-mis-use-of-generated-split">

<div class="org-src-container">

<pre  class="src src-julia"   ><code trim><span style="color: #8b94a5;"># </span><span style="color: #4F894C; font-weight: bold;">NOTE:</span><span style="color: #8b94a5;"> The one LLVM seems to have unrolled.</span>
<span style="color: #3B6EA8; font-weight: bold;">@code_llvm</span> not_unrolled_addition_old(10_001)
</code></pre>
</div>

<pre class="example">
;  @ In[137]:9 within `not_unrolled_addition_old`
define i64 @julia_not_unrolled_addition_old_53858(i64 signext %0) #0 {
top:
;  @ In[137]:11 within `not_unrolled_addition_old`
; ┌ @ range.jl:5 within `Colon`
; │┌ @ range.jl:393 within `UnitRange`
; ││┌ @ range.jl:400 within `unitrange_last`
     %.inv = icmp sgt i64 %0, 0
     %. = select i1 %.inv, i64 %0, i64 0
; └└└
  br i1 %.inv, label %L18.preheader, label %L35

L18.preheader:                                    ; preds = %top
;  @ In[137]:13 within `not_unrolled_addition_old`
  %1 = shl nuw i64 %., 1
  %2 = add nsw i64 %., -1
  %3 = zext i64 %2 to i65
  %4 = add nsw i64 %., -2
  %5 = zext i64 %4 to i65
  %6 = mul i65 %3, %5
  %7 = lshr i65 %6, 1
  %8 = trunc i65 %7 to i64
  %9 = add i64 %1, %8
  %10 = add i64 %9, -1
;  @ In[137]:14 within `not_unrolled_addition_old`
  br label %L35

L35:                                              ; preds = %L18.preheader, %top
  %value_phi10 = phi i64 [ 0, %top ], [ %10, %L18.preheader ]
  ret i64 %value_phi10
}
</pre>

</section>
<section id="slide-2023-01-29-16-57-28-The-Ugly">
<h4 id="2023-01-29-16-57-28-The-Ugly">The Ugly</h4>
</section>
<section id="slide-2023-01-29-16-57-28-The-Ugly-split">

<p>
<span class="underline"><b>Reverse-mode automatic differentiation</b></span>
</p>

<p>
ForwardDiff.jl is a pure joy, but slows down as dimensionality grows
</p>

<p>
Then one should reach for ReverseDiff.jl or Zygote.jl
</p>

<div class="fragment (appear)">
<p>
Most of the time it works really well, but sometimes you hit a real sharp edge
</p>

<p>
And sharp edges cut; they cut <i>deep</i>
</p>

<p>
Like <span class="underline">"16X slower when the function is implemented more efficiently"-deep</span>
</p>


<div class="figure">
<p><img src="assets/attachments/2023-01-25_01-01-31_Screenshot_20230125_010111.png" alt="2023-01-25_01-01-31_Screenshot_20230125_010111.png" />
</p>
</div>

</div>

<div class="fragment (appear)">

<p>
If you want to see a man in pain, you can find the full issue <a href="https://github.com/TuringLang/Turing.jl/issues/1934">here</a>
</p>

<p>
On the flip-side, once addressed (a type-instability), it's <a href="https://github.com/TuringLang/DistributionsAD.jl/pull/231">3X faster than before</a>
</p>

</div>

</section>
<section id="slide-2023-01-29-16-57-28-Overall">
<h4 id="2023-01-29-16-57-28-Overall">Overall</h4>
<p>
Julia is pretty darn awesome
</p>

<p>
Easy to get going, and you can always make it faster by just optimizing your Julia code
</p>

<p>
No need to drop down to C++
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Overall-split">
<p>
Buuuut it can't beat Python at deep learning
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Overall-split">
<p>
Otherwise, it's worth a try
</p>

<p>
Godspeed to you
</p>

</section>
<section id="slide-2023-01-29-16-57-28-Overall-split">
<p>
Fin.
</p>
</section>
</section>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/reveal.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/markdown/markdown.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.0/plugin/zoom/zoom.js"></script>


<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
plugins: [RevealMarkdown, RevealZoom]
});

</script>
</body>
</html>
